---

---



# 简单的算法思路

冒泡排序、快速排序、插入排序、希尔排序、归并排序、选择排序、堆排序、基数排序、桶排序



## 1.1排序

### 快速排序

```c++
#define IO ios::sync_with_stdio(false);cin.tie(nullptr)
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```



### 二分排序

```c++
//首先要进行排序（从小到大）
//查找相等元素中序列最小的一个
while(I < R)
{
    mid = I + R >> 1;
    if(mid >= x)
        R = mid;
    else
        I = mid + 1;
}

//查找相等元素中序列最大的一个
while(I < R)
{
    mid = I + R + 1 >> 1;
    if(mid <= x)
        I = mid;
    else
        R = mid - 1;
}
//浮点数二分法
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

==l<=r流派==

```c++
//按升序标准，以下类似upper_bound lower_bound
//找到第一个等于num的值，即大于等于num
int search(int num, int l, int r)
{
	while (l <= r)
	{
		int mid = l + r >> 1;
		if (num > a[mid]) l = mid + 1;
		else r = mid - 1;
	}
	return l;
}
//找到第一个大于num的值，即大于num
int search(int num, int l, int r)
{
	while (l <= r)
	{
		int mid = l + r >> 1;
		if (num >= a[mid]) l = mid + 1;
		else r = mid - 1;
	}
	return l;
}
```



### 归并排序

```c++
int a[N], b[N];
int ans = 0;
void msort(int l, int r)
{
	if (l == r)
		return;
	//数列分组，左右对半分
	int mid = (l + r) / 2;
	msort(l, mid);
	msort(mid + 1, r);
	//将子序列存放到临时数组
	int i = l, j = mid + 1, k = 0;
	while (i <= mid && j <= r)
	{
		if (a[i] <= a[j])
			b[k++] = a[i++];
		else
		{
			ans += mid - i + 1;//有mid - i + 1个元素大于a[j]
			b[k++] = a[j++];
		}

	}
	//将剩余的子序列放入临时数组
	while (i <= mid) b[k++] = a[i++];
	while (j <= r) b[k++] = a[j++];
	//将临时数组return回原数组a
	for (int j = 0; j < k; j++)
	{
		a[l + j] = b[j];
	}
}

signed main()
{
	int n; cin >> n;

    for (int i = 1; i <= n; i++)cin >> a[i];
    msort(1, n);

    cout << ans << endl;
	return 0;
}
```



## 1.2 时间计算

**思路：**

由于s与v中的时间单位为分，所以我们直接将88小时换算成分钟（直接8*60好了）。

由于时间可能大于11天，我们在求出来的分钟数中加上24*60

当我们把该时间减去行走时间和垃圾分类后，判断剩下的时间是否大于一天，如果大于一天就减去一天的时间，但你必须向上取整，不然行走时间就会少。

将剩下的时间除以60得到出发时。将剩下的时间对60取余得出发分。



```c++
#include<bits/stdc++.h>
using namespace std;
double s,v,m;
int n,a,t,b;
int main()
{
	cin>>s>>v;
	n=8*60+24*60;//两天总共的分钟数
	t=ceil(s/v)+10;//ceil()很重要，向上取整，否则按C++逻辑会向下取整导致行走时间少。
	n=n-t;//得出剩下的时间。
	if(n>=24*60) n-=24*60;判断是否在前一天。
	b=n%60;//得出出发分。
	a=n/60;//得出出发时
	if(a<10)//慢慢判断是否补0
	{
		if(b<10) cout<<"0"<<a<<":0"<<b;
		else cout<<"0"<<a<<":"<<b;
	}
	else
	{
		if(b<10) cout<<a<<":0"<<b;
		else cout<<a<<":"<<b;
	}
	return 0;
}
```





## 1.3逻辑，复杂条件拟合判断

![image-20220313154752398](C:\Users\albedo\AppData\Roaming\Typora\typora-user-images\image-20220313154752398.png)



```c++
#include<iostream>
using namespace std;

int main()
{
	int x;
	cin >> x;
	bool m = !(x & 1);   //利用布尔类型对不同条件进行数值量化判断
	bool n = ( x <= 12 && x > 4);
	printf("%d %d %d %d",m&&n,m|n,m&&!n||!m&&n,!m&&!n );
    //通过逻辑运算，判断不同的符合情况
	return 0;
}
```





## 1.4倍增思想

![image-20220314193042789](C:\Users\albedo\AppData\Roaming\Typora\typora-user-images\image-20220314193042789.png)

```c++
//一般我的思路

#include<iostream>
#include<algorithm>
using namespace std;

int s[3];

int main()
{
	int n, i;
	cin >> n;
	for ( i = 0; i < 3; ++i)
	{
		int k = 0;
		int a, b;
		cin >> a >> b;
		if (n % a != 0)
			k = n / a + 1;
		else
			k = n / a;
		s[i] = k * b;
	}
	int m=s[0];
	for (int i = 0; i < 3; i++)
	{
		if (s[i] < m)
			m = s[i];
	}
	cout << m;
	return 0;
}

-----------------------------------------------------------------------
                        //倍增思想//
        #include<cstdio>
    using namespace std;
    int i,j,k,n,m,w,ans;
    int main(){
        scanf("%d",&n);
        for(i=0;i<3;i++){
            scanf("%d%d",&j,&k);m=j;w=k;//输入并存下初始的价格与数量
            while(j<n){j<<=1;k<<=1;}//价格与数量不断*2直到数量大于n
            while(j>n){j-=m;k-=w;}//*2有可能导致买太多了，减去一些
            while(j<n){j+=m;k+=w;}//减去之后又可能太少了，加上一些
            //其实就是大幅度地上调，然后做一些微调
            if(k<ans||ans==0)ans=k;//判断是否是最小花费
        }
        printf("%d\n",ans);
        return 0;//输出并返回
    }


```





## 1.5 随机数生成

```c++
#include <time>

srand((unsigned)time(NULL));
int mm=rand();
//此时mm的值为一个随机数


//高性能随机函数，c++内置函数
std::mt19937 generator(std::chrono::system_clock::now().time_since_epoch().count());
unsigned int random1 = generator();
unsigned int random2 = generator();
unsigned int random3 = generator();
printf("%d\n%d\n%d\n", random1, random2, random3);

shuffle(a, a + n, generator;
```

## 1.6欧拉筛

```c++
#include<iostream>
const int maxn = 2e5 + 10;
using namespace std;
bool isprime[maxn];//首先假设所有数字都是素数
vector<int> prime;//放筛出来的素数
int cnt = 0;//计量一共筛了多少个数字
void slove(int n)
{
	memset(isprime, 1, sizeof(isprime));//初始化所有数字都为素数
	for (int i = 2; i <= n; i++)
	{
		if (isprime[i])//如果是素数，直接加入prime数组
		{
			prime.push_back(i);
		}
        //欧拉筛的核心
		for (int j = 0; j <prime.size(); j++)//对每个数字都进行欧拉筛操作
		{
			if (i * prime[j] > n)//如果要筛的数字大于提供的范围n则break；结束筛选
				break;
			isprime[i * prime[j]] = 0;//否则筛去该数字
			cnt++;
			if (i % prime[j] == 0)//遇到第一个可以整除i的质数因子，break
				break;
		}
	}
}
int main()
{
	int n;
	cin >> n;//输入筛选的范围
	slove(n);
	while(!prime.empty())
	{
		int t = prime.back();
		prime.pop_back();
		cout << t << " ";
	}
	return 0;
}

```

### 埃氏筛

```c++
#include <stdio.h>
#include <math.h>
bool is_prime[1000];
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i <= n; i++) {
        is_prime[i] = true; //初始化所有的数为素数
    }
    for (int i = 2; i <= sqrt(n); i++) 
    { //从第一个素数2开始筛选
        if (is_prime[i]) 
        {  //如果是素数
            for (int j = i * i; j <= n; j += i)
                //从平方开始，尽量避免重复剔除 
            {  //则剔除掉它的倍数
                is_prime[j] = false;
            }
        }
    }
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) {
            printf("%d\n", i);
        }
    }
    return 0;
}
```



## 1.7并查集

```c++
//思路：用一个数组f表示集合的从属关系，每个集合设置一个头头，例如{1，2，4}，假如1做头头
//就将f[1]=1,f[2]=1,f[4]=1;很轻松的就用头头表示了一个集合

#include<bits/stdc++.h>
using namespace std;
int i,j,k,n,m,s,ans,f[10010],p1,p2,p3;
//f[i]表示i的集合名
int find(int k){
	//路径压缩
    if(f[k]==k)
        return k;
    else//返回的过程中将每个节点的父节点设为同一个，如果不想压缩路径可以直			接return find(f[k])
    	return f[k]=find(f[k]);
    
}
int main()
{
    cin>>n>>m;
    for(i=1;i<=n;i++)
        f[i]=i;//一开始每个单个元素都是一个集合
    
    for(i=1;i<=m;i++){
        cin>>p1>>p2>>p3;
        if(p1==1)//将p2 p3放入一个集合也就是p2 p3的头头，操作为将p2的头的头设为p3的头
            f[find(p2)]=find(p3);
            //p3打赢了p2
        else
            if(find(p2)==find(p3))
            //是否是一伙的
                printf("Y\n");
            else
                printf("N\n");
    }
    return 0;
}
```

## 1.8 高精度

### 高精度除法

```cpp
void solve() {
	int a, b, k; cin >> a >> b >> k;

	if (a == b) {
		cout << "1." << string(k, '0');
		return;
	}

	string ans = "0.";
	for (int i = 0; i <= k; i++) {
		a *= 10;
		ans.push_back(a / b + '0');
		a %= b;
	}

	if (ans.back() >= '5') {//四舍五入
		ans.pop_back();
		char tmp = ans.back() + 1;
		ans.pop_back();
		ans.push_back(tmp);
	}
	else ans.pop_back();

	cout << ans;
}
```

### 高精度乘法

```c++
vector<int> mul(vector<int>& a, vector<int>& b)
{
	vector<int> C(a.size()+b.size());

	int t = 0;
	for (int j = 0; j < b.size(); j++)
		for (int i = 0; i < a.size() ; i++)
		{
			C[i + j] += b[j] * a[i];
			C[i + j + 1] += C[i + j] / 10;
			C[i + j] %= 10;
		}

	while (C.size() > 1 && C.back() == 0) C.pop_back();

	return C;
}

int main()
{
	string s; cin >> s;
	string t; cin >> t;
	int szs = s.size(), szt = t.size();
	vector<int> a(szs), b(szt);
	for (int i = 0; i < s.size(); i++)a[szs - 1 - i] = s[i]-'0';
	for (int i = 0; i < t.size(); i++) b[szt - 1 - i] = t[i] - '0';
	vector<int> ans = mul(a, b);
	reverse(all(ans));
	for (auto x : ans)cout << x;
	return 0;
}
```

### 高精度加法

```c++
vector<int> add(vector<int>& a, vector<int>& b)
{
	vector<int> c(a.size() + b.size());
	int t = 0;
	for (int i = 0; i <= a.size(); i++)
	{
		if (i < a.size()) t += a[i] + b[i];
		c[i] = t % 10;
		t /= 10;
	}

	while (c.size() > 1 && c.back() == 0) c.pop_back();

	return c;
}

int main()
{
	string s; cin >> s;
	string t; cin >> t;
	int szs = s.size(), szt = t.size();

	if (s.size() < t.size())//数字对齐
		s = string(szt - szs, '0') + s;
	else
		t = string(szs - szt, '0') + t;

	szs = s.size(), szt = t.size();
	vector<int> a(szs), b(szt);
	for (int i = 0; i < s.size(); i++)a[szs - 1 - i] = s[i] - '0';
	for (int i = 0; i < t.size(); i++) b[szt - 1 - i] = t[i] - '0';
	vector<int> ans = add(a, b);
	reverse(all(ans));
	for (auto x : ans)cout << x;
	return 0;
}
```

### 高精度减法

```c++
//仅限 a>=b && a>=0 && b>=0
vector<int> sub(vector<int>& a, vector<int>& b)
{
	vector<int> c(a.size() + b.size());
	int t = 0;
	for (int i = 0; i <= a.size(); i++)
	{
		if(i<a.size()) t = a[i] - t - b[i];
		c[i] = (t + 10) % 10;
		if (t < 0)t = 1;
		else t = 0;
	}

	while (c.size() > 1 && c.back() == 0) c.pop_back();

	return c;
}
int main()
{
	string s; cin >> s;
	string t; cin >> t;
	int szs = s.size(), szt = t.size();

	if (s.size() < t.size())
		s = string(szt - szs, '0') + s;
	else
		t = string(szs - szt, '0') + t;

	szs = s.size(), szt = t.size();
	vector<int> a(szs), b(szt);
	for (int i = 0; i < s.size(); i++)a[szs - 1 - i] = s[i] - '0';
	for (int i = 0; i < t.size(); i++) b[szt - 1 - i] = t[i] - '0';
	vector<int> ans = sub(a, b);
	reverse(all(ans));
	for (auto x : ans)cout << x;
	return 0;
}
```

## 1.9 ST表

```c++
//预处理
void ST_prework(){
    for(int i = 1; i <= n; i++) f[i][0] = a[i];
    int t = log(n)/log(2) + 1;
    for(int j = 1; j <= t; j++){
        for(int i = 1; i <= n - (1<<j) + 1; i++)
            f[i][j] = max(f[i][j-1], f[i + (1<<(j - 1))][j - 1]);
    }
}
//询问
int ST_query(int l, int r){
    int k = log(r - l + 1) / log(2);
    return max(f[l][k], f[r - (1<<k) + 1][k]);
}
```

## 位运算

![image-20230318132030251](C:\Users\qwqcoder\Desktop\算法\assets\image-20230318132030251.png)



```c++
//判断两数是否异号
int x, y;
bool f = ((x ^ y) < 0);

//判断一个数是否为2的幂次
int x;
bool f = (x & (x - 1)) == 0;

//有趣的比较大小函数，（位运算）
int x, y, res;
//计算较小值
res = y ^ ((x ^ y) & -(x < y));
//计算较大值
res = x ^ ((x ^ y) & -(x < y));

//交换两个数
void myswap(int a, int b){
    b ^= a;
    a ^= b;
    b ^= a;
}

//计算一个数二进制有几个 1
int x, cnt = 0;
while(x){
    x &= (x - 1);
    cnt ++;
}

//树状树状lowbit
int lowbit(x){return x & (-x);}

//枚举二进制数位上为1的二进制数集合
 for (int s = v; s; s = (v & (s - 1))) 
     
//枚举二进制数位为1的二进制超集
 for(int s = v;;s = (v | (s + 1)))
 {
     if(s == ((1 << n) - 1))break;
 }

//枚举二进制含有特定数量1的二进制集合
int x, y;
int t = (x | (x - 1)) + 1;
y = t | ((((t & -t) / (x & -x)) >> 1) - 1);

```

### 例题 1 [G-A Xor B Problem again_二进制包含1的子集](https://ac.nowcoder.com/acm/contest/52244/G)

```c++
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0);cin.tie(0)
using i64 = long long;
const int maxv = (1 << 17), maxn = 1e5 + 10;
int sum[maxv], val[maxv], vis[maxv], a[maxn];
i64 ans;


int main() {
    IO;
    int n;cin >> n;
    bin[0] = 1;
    //1e5 差不多就是 19位数
    
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        sum[a[i]]++;
    }
    for (int i = 1; i <= n; i++) {
        int v = 0;
        //取出为 0 的二进制位
        for (int j = 0; j < 17; j++) {
            if ((a[i] >> j & 1) == 0) {
                v |= 1 << j;
            }
        }
        //cout << "v = " << v << ' ' << "a[i] = " << a[i] << endl;
        if (vis[v]) {
            ans += val[v];
        } 
        else 
        {
            for (int s = v; s; s = (v & (s - 1))) 
                val[v] += sum[s];
            
            val[v] += sum[0];
            ans += val[v];
            vis[v] = 1;
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

# STL大法

## 2.1reverse( )

```c++
#include<bits/stdc++.h>   //文件头
using namespace std;
string a;                 //定义字符串
int main() 
{
    cin>>a;               //输入
    reverse(a.begin(),a.end());  //反转
    cout<<a;              //输出
    return 0;             //养成好习惯
}
```



## 2.2 map的使用

思路：使用map<string ,int > 对名称和年龄进行绑定



```c++
#include <iostream>
#include <map>//引用头文件
using namespace std;


map<string, int> id =   //类似于枚举类型
{
        {"Ox",0},{"Tiger",1},{"Rabbit",2},{"Dragon",3},{"Snake",4}
        ,{"Horse",5},{"Goat",6},{"Monkey",7},{"Rooster",8},{"Dog",9},
        {"Pig",10},{"Rat",11}
};

int main() {
   
    map<string, int > p;
    p["Bessie"] = 0;

    int n;
    cin >> n;
    while (n--)
    {
        string s[8];
        for (int i = 0; i < 8; i++)
            cin >> s[i];

            if (s[3] == "previous")
            {
                int x = p[s[7]], y = id[s[4]];
                int r = ((x - y) % 12 + 12) % 12;//重要的 模取正算法
                if (!r) r = 12;
                p[s[0]] = x - r;
            }

            else if(s[3] == "next")
            {
                int x = p[s[7]], y = id[s[4]];
                int r = ((y - x) % 12 + 12) % 12;
                if (!r) r = 12;
                p[s[0]] = x + r;
            }
        }
   

    cout << abs(p["Elsie"]) << endl;

   return 0;
}
```

```c++
//如果要改变map的排序方式要包含<xfunctional>
    
    #include<map>
	#include<iostream>
	using namespace std;
    map<int ,string> p;
  //  三种插入方式
    p.insert(make_pair(1,"wx"));
	p.insert(map<int,string>::value_type(2,"wx"));
	p.insert(pair<int,string>(3,"wx"));
	p.insert({4,"wx"})
```



# 前缀和与差分 大法

## 一阶差分

**思路：**

构造一个全为0的数组s，如果一个产品在2到6之间生产，那么将s[2]到s[6]的元素全部加1，可想而知，生产时间重合的产品会使得某些元素重复加1，那么最后可以根据，最大的那个元素判断同一时间的最大生产数。[缀和与差分 图文并茂 超详细整理（全网最通俗易懂）_林深不见鹿 的博客-CSDN博客_前缀和与差分](https://blog.csdn.net/weixin_45629285/article/details/111146240?ops_request_misc=%7B%22request%5Fid%22%3A%22164683154216780271540199%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=164683154216780271540199&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-111146240.es_vector_control_group&utm_term=前缀和与差分&spm=1018.2226.3001.4187)



**解析：**

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;
const int MAX = 1e8 + 100;

int s[MAX] = { 0 };   //构造一个数列


int main() 
{
	int n;
	int num=0;
	scanf("%d", &n);
	int l, r;
	for (int i = 1; i <= n; i++)
	{
		scanf("%d%d", &l, &r);
		s[l] += 1;
		s[r + 1] -= 1;
	}

	for (int i = 1; i <= MAX-1; i++)
	{
		s[i] = s[i] + s[i - 1];
	}
	
	for (int i = 1; i <= MAX - 1; i++)
		if (s[i] > num)
			num = s[i];
	printf("%d", num);
}
```

**思路：**

构造一个全为0的数组s，如果一个产品在2到6之间生产，那么将s[2]到s[6]的元素全部加1，可想而知，生产时间重合的产品会使得某些元素重复加1，那么最后可以根据，最大的那个元素判断同一时间的最大生产数。



## 二阶差分

# 实用函数

## 1.向下取整，向上取整

```c++
double a;
//四舍五入
int n=(int)(a/2+0.5);
```

## 2.平方根立方根

```c
sqrt(a)//平方根
cbrt(a)//立方根
```

## 3.快速幂

```c++
typedef long long ll
ll salculate(ll a,ll b,ll c)
{
    ll ans = 1;
    a %= c;//防止一开始的a过大
    while (b)
    {
        if(b & 1)
        {
            ans = (a * ans) % c;
        }
        else
        {
            a *= a;
            b >> 1;
        }
    }
    return ans;
}
```

## 4.模拟队列

### 单调队列

```c++
int h = 0, t = -1;
for(int i = 1;i <= n;i++){
	if(h<=t && q[h]<i - m + 1) h++;
    while(h<=t && a[i] >= a[q[t]]) t--;
    q[++t] = i;
}
```



# 数学知识

## 结论

==n方差分解==
$$
a^n-b^n =\\(a^m-b^m)(a^{n-m}b^0+a^{n-2m}b^m+\cdots+a^{n\bmod m}b^{n-m-n\bmod m})+b^{m\lfloor n/m\rfloor}(a^{n\bmod m}-b^{n\bmod m})
$$
==gcd等式==
$$
\gcd(a^m-b^m,a^n-b^n) = a^{\gcd(m,n)} - b^{\gcd(m,n)}.
$$


## 构造

==完全数构造lcm=sum==

![image-20230131165432919](C:\Users\qwqcoder\Desktop\算法\assets\image-20230131165432919.png)

## 费马小定理

==引理==：当 p 是质数时，其因子只有 1 和 p 两个。因此，若两个数相乘是 p 的倍数，其中必然至少有一个是 p 的倍数。

当 a 不是 p 的倍数时，不存在 $x≠y$ 且$ 1≤x,y<p $ 使得$xa≡ya(mod \quad p)$。因为据引理，$x−y$是 p 的倍数，与 $1≤x,y<p$的限制矛盾。

进一步地，考虑 1∼p 所有数，它们乘以 a 之后在模 p 意义下互不相同，说明仍得 1∼p所有数。

因此，$\prod _{i=1}^{p−1}i≡\prod _{i=1}^{p−1}ai(mod \quad p)$。又因为$ ∏_{i=1}^{p−1}i$ 显然不是 p 的倍数，所以
$$
a^{p−1}≡1(mod \quad p)
$$


## 欧拉筛

```c++
vector<int> prime, num[100010];
int cnt = 0;
void solve(int n)
{
    for(int i = 1;i  <= n;i ++)
    {
        if(!num[i])
        {
            num[i] = i;
            prime.push_back(i);
            cnt++;
        }
   		for(int j = 1; j <= cnt;j ++)
        {
            if(prime[j] * i > n)break;
            if(i % prime[j] == 0) break;
            num[i * prime[j]] == prime[j];
        }
	}
}
```

## 整数分块



求 $\sum_{i = 1}^n \lfloor \frac{n}{i} \rfloor$

这个数列具有明显的分块特性，可以将每个块的左右边界计算出来。用 $\mathcal{O}(\sqrt n$时间算出答案。

以下是 $[1, 100]$ 的分块

![image-20230419193228651](C:\Users\qwqcoder\Desktop\算法\assets\image-20230419193228651.png)

```c++
signed main(){ IO;
	int n, sum = 0;cin >> n;
	for(int l = 1;l <= n;l ++)
	{
		int d = n / l, r = n / d;//找到最大的 r 使得 n / r 下取整等于 n / l 下取整
		sum += (r - l + 1) * d;
		l = r;
	}
	cout << sum << endl;
	return 0;
}
```

计算$\sum_{i = 1}^n n\%i$ 等价于计算$\sum_{i = 1}^nn -i * \lfloor \frac{n}{i} \rfloor$

```c++
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long u64;
signed main(){
	u64 n, sum = 0;cin >> n;
	for(u64 l = 1;l <= n;l ++)
	{
		u64 d = n / l, r = n / d;
		sum += (n - d * l + n - r * d) * (r - l + 1) / 2;
		l = r;
	}
	cout << sum % (1ll << 60) << endl;
	return 0;
}
```



## $long\ long$取模

```c++
ll mul(ll x, ll y, ll m)
{
    x %= m, y %= m;
    ll d = (long double)(x * y) / m;
    d = x * y - d * m;
    if(d < 0) d += m;
    if(d >= m) d -= m;
    return d;
}
```

## 高斯消元

+ **求行列式的值：**
  + 将矩阵$A$进行高斯消元，交换两行的时候，$sgn *= -1$;
  + 最后将对角线上的值全部相乘，再乘以$sgn$即可
+ **求矩阵的逆：**
  + 将矩阵$A$和单位矩阵$E$横向链接，然后高斯消元
  + 当$A$变成单位矩阵时，$E$就变成了$A$的逆矩阵

```c++
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long u64;
const int N = 101;
const double eps = 1e-10;
int n;
double a[N][N], b[N];
void gauss()
{
	int l = 1;
	for(int i = 1;i <= n;i ++){//枚举行（方程）
		for(int j = l;j <= n;j ++)//枚举变元
			if(abs(a[j][i]) > abs(a[l][i]))
			{//找到当前变元系数最大的那一行
				for(int k = i;k <= n;k ++)
					swap(a[l][k], a[j][k]);
				swap(b[l], b[j]);
			}
		if(abs(a[l][i] < eps))continue;

		for(int j = 1;j <= n;j ++)
			if(j != l && abs(a[j][i] > eps))
			{
				double delta = a[j][i] / a[l][i];
				for(int k = i;k <= n;k ++)
					a[j][k] -= delta * a[l][k];
				b[j] -= b[l] * delta;
			}
		++l;
	}

	for(int i = l;i <= n;i ++)
		if(abs(b[i]) > eps)
		{
			cout << "no solution\n";
			return;
		}	
	if(l <= n)cout << "infinite solution\n";
	else
		for(int i = 1;i <= n;i ++)
			printf("%.10f\n", b[i] / a[i][i]);

}
signed main(){
	cin >> n;
	for(int i = 1;i <= n;i ++)
	{
		for(int j = 1;j <= n + 1;j ++)
			if(j <= n)
				cin >> a[i][j];
			else
				cin >> b[i];
	}
	gauss();
	return 0;
}

```



## 1.乘法逆元

```c++
typedef long long ll;
ll qmi(ll a, ll b, ll mod) {//快速幂
	ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod; 
        a = a * a % mod;
        b >>= 1; 
    }
	return res;
}
int main( )
{
    int a; cin >> a;
    int mod; cin >> mod;
    cout << qmi(a, mod - 2, mod);// a 的乘法逆元
    return 0;
}
```

## 2.欧拉函数

![euler](assets/euler.png)

+ ==性质1==
  $$
  \sum_{1\le i \le n} [gcd(n, i)=1] = n*\phi(n)/2
  $$

+ ==性质2==
  $$
  if \quad gcd(a,b)=1, \quad \phi(ab) = \phi(a)\phi(b)
  $$

+ ==性质3==
  $$
  \sum_{d|n} \phi(d) = n
  $$
  <img src="C:\Users\qwqcoder\Desktop\算法\assets\image-20230214185300143.png" alt="image-20230214185300143"  />

```c++
int get_euler(int m)
{
    int res = m;
   	int n = m;
    for(int i = 2; i * i <= n; i ++)
    {
        if(n % i == 0)
        {
            res = res * (i - 1) / i;
            while(n % i ==0) n /= i;
        }
    }
}

//筛法线性求欧拉函数
const int N = 1e7;
int p[N], st[N], cnt = 0;
int shi[N];
void get_shi(int n)
{
    for(int i = 2; i <= n; i ++ )
    {
        if(st[i] == 0)
        {
            phi[i] = i-1;
            p[cnt++] = i;
        }
        for(int j = 0; j < cnt; j ++ )
        {
            int m = i * p[j];
            st[m] = 1;
            if(i % p[j] == 0)
            {
                phi[m] = p[j] * phi[i];
           	 	break;
            }
            else
                phi[m] = (p[j] - 1) * phi[i];
        }
    }
}
```



## 3.欧拉定理，扩展欧拉定理

<img src="C:\Users\王雄\AppData\Roaming\Typora\typora-user-images\AS@N@CLO]ZDMQO`CUSIE3AA.png" alt="img" style="zoom:60%;" />

<img src="C:\Users\王雄\AppData\Roaming\Typora\typora-user-images\_@]%(HSE45K)]}}YN[3]F.png" alt="img" style="zoom:60%;" />

<img src="./assets/1.png" alt="1" style="zoom: 67%;" />

```c++
int euler(int n)
{
    int res = n;
    int m = n;
    for(int i = 2; i * i <= m; i ++)
    {
        if(m % i == 0)
            res = res* (i - 1) / i;
        while(m % i == 0) m /= i;
    }
    return res;
}
int depow(int phi)// phi 为 m 的 欧拉函数值
{
    int b = 0; int flag = 0;
    for(int i = 0; s[ i ]; i ++){// b过大，用字符串存储表示
        b = b * 10 + b[i]-'0';//类似秦九韶算法
        if(b > phi) flag = 1, b %= phi;
    }
    if(flag) b += phi;
    return b;
}
```

### 欧拉定理重要推论

![Screenshot_20221125_204120_com.jideos.jnotes](./assets/Screenshot_20221125_204120_com.jideos.jnotes.png)

## 4.扩展欧几里得定理

<img src="./assets/2.png" alt="2" style="zoom:67%;" />

```c++
//普通欧几里得
int gcd(int a, int b)
{
   	return if b ? gcd(b, a % b) : a;
}

//扩展欧几里得定理
int exgcd(int a, int b, int &x,int &y)
{
    if(b == 0)
    {
        x = 1, y = 0;
        return a;
    }
    int x1, y1, d;
    d = exgcd(b, a % b, x1, y1);
    x = y1, y = x1 - a/b*y1;
    return d;
}
```

![扩欧](./assets/扩欧.png)

## 5.中国剩余定理CRT

$$
x\equiv r_1(mod \quad m_1) \\
x\equiv r_2(mod \quad m_2)\\
x\equiv r_3(mod\quad m_3)\\
x\equiv r_4(mod\quad m_4)\\
....\\
x\equiv r_n(mod \quad m_n)
$$

![image-20230127101118875](C:\Users\qwqcoder\Desktop\算法\assets\image-20230127101118875.png)

==证明==

![image-20230127102229488](C:\Users\qwqcoder\Desktop\算法\assets\image-20230127102229488.png)

```c++
ll exgcd(ll a, ll b, ll &x, ll &y)
{
    if(b == 0){x = 1, y = 0; return a;};
    ll d, x1, y1;
    d = exgcd(b, a%b, x1, y1);
    x = y1, y = x1 - a / b * y1;
    return d;
}

ll CRT(ll m[], ll r[])
{
    ll M = 1, ans = 0;
    for(int i = 1;i <= n;i ++) M *= m[i];
    for(int i = 1;i <= n;i ++)
    {
        ll c = M / m[i], x, y;
        ecgcd(c, m[i], x, y);
        ans = ans(ans + r[i] * c[i] * x % M) % M;
    }
    return (ans % M + M) % M;
}
```

## 6.扩展中国剩余定理

==原来互质的n个数，$m_1 m_2...m_n$不再互质==

![image-20230127160719154](C:\Users\qwqcoder\Desktop\算法\assets\image-20230127160719154.png)

==合并不定方程的思想==

![image-20230127160734768](C:\Users\qwqcoder\Desktop\算法\assets\image-20230127160734768.png)

==合并过程==

将两个同余方程，等价转换成等式
$$
x \equiv r_1(mod \quad m_1)\\
x \equiv r_2(mod \quad m_2)
$$
==变化为不定方程==
$$
x = m_1 p+r_1 \\ 
x = m_2q+r_2
$$
==两式作差得到==$m_1p - m_2q = r_2 - r_1$

将p，q看做变量，只有$gcd(m_1,m_2)|r_2-r_1$才有解

==根据扩欧算法==

设$d = (r_2-r_1)/gcd(m_1,m_2)$

得到$p = p_0*d \quad \quad q = q_0*d$

==通解为==
$$
P=p+\frac{m_2}{gcd(m_1,m_2)}*k\\
Q=q-\frac{m_1}{gcd(m_1,m_2)}*k
$$
==将P或者Q待会最初的不定方程==

以待入P为例得到
$$
x = m_1P+r_1 = \frac{m_1m_2}{gcd(m_1,m_2)}*k+m_1p+r_1\\
$$


可使得两个方程合并为一个方程$x \equiv r(mod \quad m)$

其中$r = m_1p+r_1$	$m = lcm(m_1,m_2)$

```c++
ll exgcd(ll a, ll b, ll &x, ll &y)
{
    int d, x1, y1;
    if(b == 0){x = 1, y = 0; return a;}
    d = exgcd(b, a % b, x1, y1);
    x = y1, y = x1 - a / b * y1;
    return d;
}
ll EXCRT(ll m[], ll r[])
{
    ll m1, m2, r1, r2, p, q;
    m1 = m[1], r1 = r[1];
    for(int i = 1; i <= n;i ++)
    {
        m2 = m[i], r2 = r[i];
        ll d = exgcd(m1, m2, p, q);
        if((r2 - r1) % d != 0) return -1;
        p = p * (r2 - r1) / d;
        p = (p %(m2 / d)+m2/d)%(m2/d);
        r1= m1*p+r1;
        m1 = m1*m2/d;
    }
}
```



## 7.组合数

### 1.简单组合数

$$
c_m^n = c_{m-1}^{n-1}+c_{m-1}^{n}=\frac{m!}{(m-n)!*n!}
$$

------

==性质==
$$
c_n^k = c_{n-1}^{k-1}*\frac{n}{k}\\
\sum_{i=0}^n i*c_n^k = n*2^{n-1}\\
\sum_{i=0}^n i^2*c_n^k=n*(n+1)*2^{n-1}
$$


**卢卡斯定理**
$$
C(n,m)\%p=C(n/p,m/p)*C(n\%p,m\%p)\%pC(n,m)%p=C(n/p,m/p)∗C(n%p,m%p)%p
$$


```c++
//递推
//以下递推到c[60][60],c[i][j]表示i个物品中选取j个的组合排列
int c[100][100];
for(int i = 0; i <= 60; i++)
    for(int j = 0; j <= i; j++)
        if(!j)c[i][j] = 1;
	    else c[i][j] = c[i-1][j-1]+c[i-1][j];



//乘法逆元
//首先计算m！一般大数据会有取模运算
int fm[100],fmn[100];//m!,(m-n)!,n!
fm[0]=fmn[0]=fn[0]=1;
for(int i = 1; i <= 60; i ++)
    fm[i] = fm[i-1]*i%mod;


//计算(m-n)!和n！的乘法逆元 显然后者包括前者
for(int i = 1; i <= 60; i++)
    fmn[i] = fmn[i-1]*qmi(i,mod-2,mod)%mod;

//卢卡斯定理
//卢卡斯定理：C ( n , m ) % p = C ( n / p , m / p ) ∗ C ( n % p , m % p ) % p 
//...
```

### 2.==多重集组合数==





## 8.生成函数

![image-20230214171023523](C:\Users\qwqcoder\Desktop\算法\assets\image-20230214171023523.png)

```c++
```

## 9.积性函数

+ 欧拉函数

==定义==

$\phi(n)=\sum_{i=1}^n[gcd(i, n)=1]$

==性质==

$\sum_{d|n}\phi(d)=n$

> 对于 $n$ 来说，将 $n$ 的所有约数的欧拉函数值相加结果等于 $n$







+ 莫比乌斯函数

==定义==
$$
\begin{equation}
\mu(n)=\left\{
	\begin{aligned}
	&\ 1 \quad  && n=1&\\
	&\ (-1)^n \quad  && n=p_1p_2..p_n\\
	&\ 1 \quad  && x>0\\
	\end{aligned}
	\right
	.
	
\end{equation}
$$
==性质==

$\sum_{d|n}\mu(d) = [n=1]$

 

**莫比乌斯函数和欧拉函数的联系**
$$
\sum_{d|n}\mu(d)\frac{n}{d}=\phi(n)
$$


<img src="C:\Users\qwqcoder\Desktop\算法\assets\image-20230309121740535.png" alt="image-20230309121740535" style="zoom:50%;" />

## 卷积

### 狄利克雷卷积

==定义==

$f(n), g(n)$ 是两个积性函数则，$(f*g)(n)=\sum_{d|n}f(d)g$frac{n}{d})=\sum_{d|n}f$frac{n}{d})g(d)$

>  例如：$(f*g)(4) = f(1)g(4) + f(2)g(2)+f(4)g(1)$

==性质==

+ 交换律：$f*g=g*f$
+ 结合律：$(f*g)*h=f*(g*h)$
+ 分配律：$(f+g)*h = f*h+g*h$



### 常用算子函数

+ 元函数： $\varepsilon(n)=[n=1]$
+ 常数函数：$1(n)=1$
+ 恒等函数：$id(n)=n$

<img src="C:\Users\qwqcoder\Desktop\算法\assets\image-20230309123644520.png" alt="image-20230309123644520" style="zoom:50%;" />

## 和式变换

 

# 图论

## 找重心

```c++
function <void(int, int)> getRoot = [&](int x, int fa) 
{
    sz[x] = 1;
    int ok = 1;
    for (int i = he[x]; i; i = ne[i]) {
        int y = e[i];
        if (del[y] || y == fa) continue;
        getRoot(y, x);
        sz[x] += sz[y];
        if (sz[y] > tot / 2) ok = 0;
    }
    if (tot - sz[x] > tot / 2) ok = 0;
    if (ok) root = x;
};
```



## 找到环上的所有点

```c++
#include <iostream>
#include <vector>
using namespace std;
const int N = 1e6 + 10;
vector<int> to[N];
int n, m;
int dfn[N], low[N], tot, d[N];
int stk[N], instk[N], top;
int scc[N], siz[N], scc_cnt;

void tarjan(int u)
{
    dfn[u] = low[u] = ++tot;
    stk[++top] = u, instk[u] = 1;
    for (auto v : to[u])
    {
        if (!dfn[v])
        {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (instk[v])
            low[u] = min(low[u], dfn[v]);
    }

    if (dfn[u] == low[u])
    {
        scc_cnt++;
        int v;
        do {
            v = stk[top--], instk[v] = 0;
            scc[v] = scc_cnt;
            siz[scc_cnt] ++;
        } while (u != v);
    }
}

int main()
{
    cin >> n;
    int x;
    for (int i = 1; i <= n; i++) cin >> x, to[x].push_back(i);
    for (int i = 1; i <= n; i++)
        if (!scc[i]) tarjan(i);// tarjan 找到所有联通分量

    for (int i = 1; i <= n; i++)
        for (int it : to[i])
        {
            if (scc[it] == scc[i]) 
                d[scc[it]] = 1;
        }

    int res = 0;
    for (int i = 1; i <= scc_cnt; i++)
        if (d[i])
            res += siz[i];
    cout << res << endl;
    return 0;
}
```



## 无向图简单环判定

+ 时间复杂度$2^n * n * n$

==例题== https://codeforces.com/contest/11/problem/D

```c++
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(false);cin.tie(nullptr)
vector<int> e[100];

signed main() {
	IO;
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++)
	{
		int u, v;
		cin >> u >> v;
		u--, v--;
		e[u].push_back(v);//存边
		e[v].push_back(u);
	}
	//dp[st][j]表示集合st中以j为终点的路径数目
    //这里有20个点，集合最大为 (1 << 20) - 1, 终点有20个
	vector<vector<int>> dp(1 << 20, vector<int>(20));
    
    //首先初始化单一个点的状态为 1，即每个点自身到自身有1条路径
	for (int i = 0; i < n; i++)
		dp[1 << i][i] = 1;//

	int ans = 0;
    
    //枚举集合
	for (int st = 1; st < 1 << n; st++) {
		for (int j = 0; j < n; j++)
		{
             //如果集合内到j的路径不存在跳过
			if (!dp[st][j])continue;
             //否则用这个存在的集合状态更新下一个状态
            //下一个状态即是j所连的点为终点，
			for (auto v : e[j]) {
                  //为了避免枚举重复的状态，每个集合用其中最小的点作为起点
				if ((st & -st) > (1 << v)) continue;
				if (st & (1 << v))
				{
					if ((st & -st) == 1 << v)
						ans += dp[st][j];
				}
				else {
					dp[st | (1 << v)][v] += dp[st][j];
				}
			}
		}
	}
	cout << ((ans - m) >> 1);
	return 0;
}
```



## 最短路

### floyd

```c++
//初始化 
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

void floyd()
{
    for (int k = 1; k <= n; k ++ )// n 次外循环， 枚举 n 个松弛点
        for (int i = 1; i <= n; i ++ )// 之后枚举所有点对
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```



### dijkstra（朴素版）

```c++
#include<bits/stdc++.h>
#define oo 0x3f3f3f3f
const int maxn = 2e5 + 10;
int a[1000][1000]={0};
int dist[1000];
bool flag[1000];
int pre[1000];
int n, m;
using namespace std;
void dijkstra(int u)
{
	for (int i = 0; i < n; i++)//初始化距离列表，路径列表
	{
		dist[i] = a[u][i];//以初始点为源点更新距离列表
		if (a[u][i] == oo)//距离为oo则上一个点设为-1
			pre[i] = -1;
		else//否则设为原点
			pre[i] = u;
	}
	flag[u] = true;//源点标记
	dist[u] = 0;//源点到源点自己本身的距离为0
    
    //下面是dijkstra的核心代码
	for (int i = 0; i < n; i++)
	{
		int temp = oo;//用于找出下一个最短边的中间量
		int t = i;//记录最短边所连接的下一个点
		for (int j = 0; j < n; j++)
		{
			if (!flag[j] && dist[j] < temp)//如果j点未标记，且到j距离小于temp
			{
				t = j;
				temp = dist[j];
			}
		}
        //得到t点
		if (t == u)//如果t==u说明源点是一个孤立点，到任何点距离都为无穷
			return;
        
		flag[t] = true;//标记t点
		for (int j = 0; j < n; j++)
		{
			if (!flag[j] && a[t][j] < oo)
			{
				if (dist[j] > (dist[t] + a[t][j]))
				{
					dist[j] = dist[t] + a[t][j];
					pre[j] = t;
				}
			}
		}
	}
    
}

void init()
{
	memset(a, oo, sizeof(a));//邻接矩阵，初始值每条边都为oo
	memset(dist, 0, sizeof dist);//各点和源点的距离初始为0，或者无穷都可以，之后会有重新赋值
	memset(flag, false, sizeof flag);//标记数组，意义为该点最小距离是否确定，初始化为假
	memset(pre, -1, sizeof pre);//路径数组，记录最短路径中该点的上一个节点
}

int main()
{
	
	while (cin >> n >> m && n && m)
	{
		init();//初始化
		while (m--)//输入边集合(邻接矩阵)
		{
			int u, v, w;
			cin >> u >> v >> w;
			a[u][v] = a[v][u] = min(w,a[u][v]);
		}
		int start, end;//起始点和中止点
		cin >> start >> end;
		dijkstra(start);//以起始点为源点
		if (dist[end] != oo)//如果最终到end中止点的距离为oo，没被更新说明无法到达
			cout << dist[end]<<"\n";
		else
			cout << -1 << "\n";
	}
	return 0;
}
```

### dijkstra（优先队列优化）

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int dis[N], vis[N];
int cot = 0;
int n, m;
vector<array<int, 2>> e[N];
void dijkstra()
{
    memset(dis, 0x3f, sizeof(dis));//把距离初始化为最大值
    dis[1] = 0;//设置1为源点
    priority_queue<array<int, 2>, vector<array<int, 2>>, greater<array<int, 2>>>heap;//小根堆维护，方便找到最小边
    heap.push({ 0,1 });//前面是距离，后面是点
    while (heap.size())
    {
        auto t = heap.top();//auto自动识别变量类型
        heap.pop();
        int distance = t[0];
        int u = t[1];
        if (vis[u])//如果这个点已经被处理过了就不需要再处理了
            continue;
        vis[u] = true;//此时的point一定是当前距离最小的点，直接加入已处理过的点的集合
        for (auto v : e[u])//这里的i就相当于idx
        {
            int j = v[0];
            if (dis[j] > u + v[1])//因为这里的i相当于idx，所以可以用w[i]
            {
                dis[j] = u + v[1];
                heap.push({ dis[j],j });//注意是先存距离，再存点
            }
        }
    }
}

int main()
{
    .....//常规写法
        return 0;
}
```



### spfa

```c++
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int N=1e5+10;
int h[N],e[N],w[N],ne[N],idx=0;
int dist[N],cnt[N];//各点到源点的距离
bool st[N];
int n,m;
void add(int a,int b,int c){
    e[idx]=b;w[idx]=c;ne[idx]=h[a];h[a]=idx++;
}

void spfa(int x)
{
    queue<int> q;
    memset(dis,0x3f,sizeof(dis));
    dis[x] = 0;q.push(x);
    vis[x] = 1;
    while(!q.empty())
    {
        int t=q.front(); q.pop();
        vis[t] = 0;
        if(cnt[t] > n)
        {
            puts("Forever love");
            exit(0);
        }
        for(int i = h[t] ; i ; i = ne[i])
        {
            int j = e[i];
                if(dis[t] + w[i] < dis[j])
                {
                    dis[j] = dis[t] + w[i];
                    if(!vis[j]) q.push(j),cnt[j]++,vis[j] = 1;
                }
         }
    }
    return;
}
int main(){
    int s,t,w;
    cin>>n>>m;
    for(int i = 1;i <= m;i++)
    {
        scanf("%d%d%d",&s,&t,&w);
        adde(s,t,-w);
    }
    spfa(1);
    int ans = dis[n];
    spfa(n);
    printf("%d",min(ans,dis[1]));
    return 0;
}
```

## 生成树

### kruskal

```c++
#include<bits/stdc++.h>
using namespace std;
int f[2000002],n,x,pp,qq,xian,bian,ans,m;

struct node {//结构体不多说
	int u,v,w;
} p[2000002];

bool cmp(node a,node b)  //比较函数（sort）
{
    return a.w<b.w;
}  

int find(int x) {
	if(f[x]==0)
        return x;			//并查集模板
	else 
        return f[x]=find(f[x]);
}

int main() 
{
	scanf("%d %d",&m,&n);
	for(int i=1; i<=n; i++) 
    {
        scanf("%d %d %d",&pp,&qq,&x);
        p[xian].u=pp;
        p[xian].v=qq;
        p[xian++].w=x;
    }
	sort(p,p+xian,cmp);		
    //直接进行排序
	for(int i=0; i<xian; i++) 
    {
		int u=p[i].u,v=p[c++i].v,w=p[i].w;
        int t1=find(p[i].u);//寻找节点u的父节点
        int t2=find(p[i].v);//寻找节点v的父节点
        if(t1!=t2)//如果二者不属于一个集合，则需要合并
        {
            ans+=w;//累加每个条边的权值
            f[t1]=t2;//将u的父节点设为v的父节点
            bian++;//边的计数加一
        }
		if(bian==n-1)break;//当边的数量等于节点数量减一时，刚好构成最小生成树
	}
    
	printf("%d",ans);//输出最小生成树的权值之和
}
```

### 最小异或树

[CF888G Xor-MST(异或最小生成树) - ResuscitatedHope - 博客园 (cnblogs.com)](https://www.cnblogs.com/ResuscitatedHope/p/13811624.html)

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=200010;
int trie[N*30][2],a[N],tot=0;
void insert(int x)
{
    int p=0;
    for(int i=30;i>=0;i--)
    {
        int ch=(x>>i)&1;
        if(!trie[p][ch])
            trie[p][ch]=++tot;
        p=trie[p][ch];
    }
}
int solve(int root1,int root2,int bit)
{
    if(bit<0)
        return 0;
    int ans1=-1,ans2=-1;
    if(trie[root1][0]&&trie[root2][0])
        ans1=solve(trie[root1][0],trie[root2][0],bit-1);
    if(trie[root1][1]&&trie[root2][1])
        ans2=solve(trie[root1][1],trie[root2][1],bit-1);
    if(ans1>=0&&ans2>=0)
        return min(ans1,ans2);
    if(ans1>=0)
        return ans1;
    if(ans2>=0)
        return ans2;
    if(trie[root1][0]&&trie[root2][1])
        ans1=solve(trie[root1][0],trie[root2][1],bit-1)+(1<<bit);
    if(trie[root1][1]&&trie[root2][0])
        ans2=solve(trie[root1][1],trie[root2][0],bit-1)+(1<<bit);
    if(ans1>=0&&ans2>=0)
        return min(ans1,ans2);
    if(ans1>=0)
        return ans1;
    if(ans2>=0)
        return ans2;
}
long long ans=0;
void dfs(int start,int bit)
{
    if(bit<0)
        return ;
    if(trie[start][0]&&trie[start][1])
        ans=ans+1ll*solve(trie[start][0],trie[start][1],bit-1)+(1<<bit);
    if(trie[start][0])
        dfs(trie[start][0],bit-1);
    if(trie[start][1])
        dfs(trie[start][1],bit-1);
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        insert(a[i]);
    }
    dfs(0,30);
    cout<<ans<<endl;
    return 0;
}

```



## Taryan

### 划分联通分量

==求强连通分量==

```c++
vector<int> e[N];
int dfn[N];//时间戳, 第一次访问的顺序
int low[N];//追溯值，从节点x能够到达的最早的节点
int tot = 0; //访问顺序计数器
int sta[N],vis[N],top = -1;// 手写栈，vis[N]标记节点是否入栈
int scc[N],siz[N],cnt = 0;// 最大联通量数组scc siz记录分量大小
void tarjan(int x)
{
    dfn[x] = low[x] = ++tot;
    sta[++top] = x, vis[x] = 1;
    for(auto y : e[x])
    {
        if(dfn[y] == 0)
        {
            tarjan(y);
            low[x] = min(low[x], low[y]);
        }
        else if(vis[y])
            low[x] = min(low[x], dfn[y]);
    }
    
    if(low[x] == dfn[x])
    {
        cnt++;int y;
        do{
        y = sta[top--], vis[y] = 0;
        scc[y] = cnt;
        siz[cnt]++;
        }while(y != x);
    }
}
```

### 割边

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10;
struct edge { int u, v; };
vector<edge> e;
vector<int> h[N];
int dfn[N], low[N], tot = 0, cnt = 0;
struct bridge { int x, y; } bri[N];

void add(int a, int b) {
    e.push_back({ a, b });
    h[a].push_back(e.size() - 1);
    e.push_back({ b, a });
    h[b].push_back(e.size() - 1);
}

void tarjan(int x, int to_x)
{
    dfn[x] = low[x] = ++tot;
    for (auto j : h[x])
    {
        int y = e[j].v;
        if (!dfn[y])
        {
            tarjan(y, j);
            low[x] = min(low[x], low[y]);
            if (low[y] > dfn[x])
                bri[++cnt] = { x,y };
        }
        else if (j != (to_x ^ 1))
            low[x] = min(low[x], dfn[y]);
    }
}

signed main()
{
    int n, m;
    cin >> n >> m;
    while(m --){
        int a, b;
        cin >> a >> b;
        add(a, b);
	}
    return 0;
}
```

### 割点

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10;
vector<int> e[N];
int dfn[N], low[N], tot = 0;
int cut[N] = { 0 };
int root;


void tarjan(int x)
{
    dfn[x] = low[x] = ++tot;
    int flag = 0;
    for (auto y : e[x])
    {
        if (!dfn[y])
        {
            tarjan(y);
            low[x] = min(low[x], low[y]);
            if (low[y] >= dfn[x])
            {
                flag++;
                if (x != root || flag > 1)cut[x] = true;
            }
        }
        else 
            low[x] = min(low[x], dfn[y]);
    }
}

int main()
{
    int n, m; cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        int u, v;
        cin >> u >> v;
        if (u == v)continue;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    for (int i = 1; i <= n; i++)
        if (!dfn[i])root = i, tarjan(root);
    int sum = 0;
    for (int i = 1; i <= n; i++)
    {
        if(cut[i])
            sum++;
    }
    cout << sum << endl;
    for (int i = 1; i <= n; i++)
        if(cut[i])cout << i << " ";
    return 0;
}
```



## LCA

![dfs序lca](C:\Users\qwqcoder\Desktop\算法\assets\dfs序lca.jpg)

### LCA倍增

==倍增求lca==

```c++
#include <bits/stdc++.h>
#define oo 0x3f3f3f3f
#define ll long long
#define PII pair<int, int>
#define IO ios::sync_with_stdio(0);cin.tie(0)
const int maxn = 5e5 + 10;
using namespace std;
struct
{
	int v;
	int ne;
}e[maxn*2];
int h[maxn], lg[maxn],p[maxn][30],deep[maxn];
int tot = 0;

void add(int u, int v)
{
	e[++tot].v = v;
	e[tot].ne = h[u];
	h[u] = tot;
}

void dfs(int u, int fa)//深搜
{
	p[u][0] = fa; deep[u] = deep[fa] + 1;
	for (int i = 1; (1<<i)<=deep[u]; i++)
	{
		p[u][i] = p[p[u][i - 1]][i - 1];
	}
	for (int i = h[u]; i ; i = e[i].ne)
	{
		int j = e[i].v;
		if (j != fa)
		dfs(j, u);
	}
}

void bfs(int root)//宽搜
{	
	memset(deep, oo, sizeof deep);//初始化深度全为无穷大
	deep[root] = 1;
	queue<int>	q;
	q.push(root);

	int hh = 0, tt = 0;
	while (q.size())
	{
		int t = q.front();
		q.pop();
		for (int i = h[t]; i; i = e[i].ne)
		{
			int v = e[i].v;
			if (deep[v]>deep[t])//如果v深度大于t深度 说明v没有被搜索过
			{
				deep[v] = deep[t] + 1;//更新v深度
				q.push(v);//v加入搜索队列
				p[v][0] = t;//父节点单独赋值
				for (int i = 1; i <= lg[deep[v]]; i++)//更新v的祖先节点队列
					p[v][i] = p[p[v][i - 1]][i - 1];
			}

		}
	}
}

int LCA(int a, int b)
{
	if (deep[a] < deep[b])
		swap(a, b);
	int t = 20;

	while (deep[a] > deep[b])
	{
		if(deep[a]-deep[b]>=(1<<t))
			a = p[a][t];
		t--;
	}

	if (a == b)
		return a;
	else
	{
		for (int k = 20; k >= 0; k--)
		{
			if (p[a][k] != p[b][k])
				a = p[a][k], b = p[b][k];
		}
	}
	return p[a][0];
}

int main()
{
	int n, m, s;
	cin >> n >> m >> s;
	for (int i = 1; i < n; i++)
	{
		int u, v; cin >> u >> v;
		add(u, v), add(v, u);
	}
	dfs(1,0);
	while (m--)
	{
		int a, b; cin >> a >> b;
		int ans = LCA(a, b);
		cout << ans << endl;
	}
	return 0;
}
```

### Tarjan LCA

[322 最近公共祖先 Tarjan算法](https://www.bilibili.com/video/BV1A94y12737/?spm_id_from=333.999.0.0&vd_source=5ddf428f4d8dd2a0b8affce957592c1b)

```c++
const int N = 1e5 + 10;
vector<int> e[N];
vector<array<int, 2>> query[N]; // 存询问LCA的点对,正反都存一遍
int fa[N], vis[N], ans[N];
int find(int u)
{
    if(u == fa[u]) return u;
    return fa[u] = find(fa[u]);// 路径压缩
}
void tarjan(int u)
{
    vis[u] = true; // 标记，表示搜过了
    for(auto v : e[u])
    {
        if(!vis[v])
        {
        	tarjan(v);
            fa[v] = u; // 搜过子节点后将其指向父节点 类似DSU
        }
    }
    for(auto q : query[u])
    {
        int v = q[0], i = q[1];
        if(vis[v]) ans[i] = find(v);
    }
}
```



## 树链剖分

==剖分基础知识点==

+ **重儿子**：父节点所有儿子中子树节点数最多的节点
+ 轻儿子：父节点中除了重儿子以外的其他儿子
+ 重边：父节点和重儿子连成的边
+ 轻边：父节点和轻儿子连成的边
+ **重链**：由多条重边链接而成的路径

![image-20230323105207236](C:\Users\qwqcoder\Desktop\算法\assets\image-20230323105207236.png)

> 1. 整棵树会被剖分成若干条重链
> 2. 轻儿子一定会是每条重链的顶点
> 3. 任意路径被切分成不超过$logn$条链

### 1.剖分求lca

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
vector<int> e[N];
int fa[N], son[N], sz[N], dep[N];
//sz[u] 以u为根的子树的节点数
//son[u] u的重儿子
//top[u] u所在重链的顶点
//dep[u] u的深度
//fa[u] u的父节点
int top[N];//重链根节点

void dfs1(int u, int p){
	fa[u] = p;dep[u] = dep[p] + 1;sz[u] = 1;
	for (int v : e[u]){
		if (v == p)continue;
		dfs1(v, u);
		sz[u] += sz[v];
		if (sz[son[u]] < sz[v])son[u] = v;
	}
}

void dfs2(int u, int t){
	top[u] = t;//标记链头
	if (!son[u])return;//无重儿子返回
	dfs2(son[u], t);
	for (int v : e[u]){
		if (v == fa[u] || v == son[u])continue;
		dfs2(v, v);
	}
}
//
int lca(int u, int v){
	while (top[u] != top[v]){
		if (dep[top[u]] < dep[top[v]])
			swap(u, v);
		u = fa[top[u]];
	}
	return dep[u] < dep[v] ? u : v;
}

int main(){
    
	return 0;
}
```

### 2.剖分线段树

```c++
#include <bits/stdc++.h>
#define oo 0x3f3f3f3f
#define ll long long
#define OO 0x3f3f3f3f3f3f3f3f
#define IO ios::sync_with_stdio(false);cin.tie(nullptr)
#define endl "\n"
#define int ll
const int N = 2e5 + 10, M = 2 * N;
using namespace std;
int n, m, r, mod;
#define lc p << 1
#define rc p << 1 | 1
int fa[N], son[N], sz[N], dep[N];//父节点，重儿子，链大小，点深度
int w[N];//点权
int top[N];//重链根节点，重链中深度最小的节点
int nw[N], id[N];//映射之后的点权，点集映射关系
int cnt = 0;
vector<int> e[N];
void dfs1(int u, int p)
{//第一遍dfs 确定重儿子，重链
    fa[u] = p;
    dep[u] = dep[p] + 1;
    sz[u] = 1;
    for (int v : e[u])
    {
        if (v == p)continue;
        dfs1(v, u);
        sz[u] += sz[v];
        if (sz[son[u]] < sz[v])son[u] = v;
    }
}

void dfs2(int u, int t) {
    top[u] = t, id[u] = ++cnt, nw[cnt] = w[u];
    if (!son[u])return;
    dfs2(son[u], t);
    for (int v : e[u]) {
        if (v == fa[u] || v == son[u])continue;
        dfs2(v, v);
    }
}

///////////////////---------线段树部分---------------//////////////////
struct tree {
    int l, r;
    ll laz, sum;
    tree() { l = 0, r = 0, laz = 0, sum = 0; }
}tr[N << 2];

void pushup(int p) {
    tr[p].sum = (tr[lc].sum + tr[rc].sum) % mod;
}

void pushdown(int p)
{
    if (tr[p].laz)
    {
        tr[lc].sum += (tr[lc].r - tr[lc].l + 1) * tr[p].laz;
        tr[rc].sum += (tr[rc].r - tr[rc].l + 1) * tr[p].laz;
        tr[lc].sum %= mod;
        tr[rc].sum %= mod;
        tr[lc].laz += tr[p].laz;
        tr[rc].laz += tr[p].laz;
        tr[p].laz = 0;
    }
}

void build(int p, int l, int r)
{
    tr[p].l = l, tr[p].r = r;
    if (l == r) { tr[p].sum = nw[r]; return; }
    int mid = l + r >> 1;
    build(lc, l, mid), build(rc, mid + 1, r);
    pushup(p);
}

void update(int p, int l, int r, int k)
{// 朴素线段树区间更改操作，有laz
    if (tr[p].l >= l && tr[p].r <= r)
    {
        tr[p].laz += k;
        tr[p].sum += k * (tr[p].r - tr[p].l + 1);
        tr[p].sum %= mod;
        return;
    }
    pushdown(p);
    int mid = tr[p].r + tr[p].l >> 1;
    if (l <= mid) update(lc, l, r, k);
    if (r > mid) update(rc, l, r, k);
    pushup(p);
}

void update_path(int u, int v, int k)//将u，v在树上最短路径的所有点权加上k
{
    while (top[u] != top[v])
    {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        update(1, id[top[u]], id[u], k);
        u = fa[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v);
    update(1, id[v], id[u], k);
}

void update_tree(int u, int k)// 更新以u为根节点的子树内所有点权
{
    update(1, id[u], id[u] + sz[u] - 1, k);
}

ll query(int p, int l, int r) {//朴素线段树的区间询问
    if (tr[p].l >= l && tr[p].r <= r) return tr[p].sum;
    pushdown(p);
    ll res = 0;
    int mid = tr[p].l + tr[p].r >> 1;
    if (l <= mid) res += query(lc, l, r);
    if (r > mid) res += query(rc, l, r);
    return res % mod;
}

int query_path(int u, int v)// 球 u， v在树上最短路径的点权和
{
    ll res = 0;
    while (top[u] != top[v])
    {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res += query(1, id[top[u]], id[u]);
        u = fa[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v);
    res += query(1, id[v], id[u]);
    return res;
}

ll query_tree(int u) {
    return query(1, id[u], id[u] + sz[u] - 1);
}

signed main() {
    IO;
    cin >> n >> m >> r >> mod;
    for (int i = 1; i <= n; i++)
        cin >> w[i];
    for (int i = 1; i < n; i++)
    {
        int u, v;
        cin >> u >> v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    dfs1(r, 0);
    dfs2(r, r);
    build(1, 1, cnt);
    for (int i = 1; i <= m; i++)
    {
        int op; cin >> op;
        if (op == 1)
        {// 更新树上节点x到y最短路径上每个点权加z
            int x, y, z;
            cin >> x >> y >> z;
            update_path(x, y, z);
        }
        else if (op == 2)
        {// 询问树上节点x到y最短路径上的点权和
            int x, y; cin >> x >> y;
            cout << query_path(x, y) % mod << endl;
        }
        else if (op == 3)
        {// 更新树上以x为根节点的子树的点权加z
            int x, z; cin >> x >> z;
            update_tree(x, z);
        }
        else if (op == 4)
        {// 询问树上以x为根节点的子树的点权和
            int x; cin >> x;
            cout << query_tree(x) % mod << endl;
        }
    }
    return 0;
}
```



## 二分图

### 二分图基础概念

==定义==：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配

==匹配点==：匹配边上的点

==极大匹配==：是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。

==最大匹配==：是所有极大匹配当中边数最大的一个匹配,设为M。选择这样的边数最大的子集称为图的最大匹配问题。

==完美匹配==：一个图中所有的顶点都是匹配点的匹配，即2|M| = |V|。完美匹配一定是最大匹配，**<u>但并非每个图都存在完美匹配</u>。**

==最优匹配==：最优匹配又称为带权最大匹配，是指在带有权值边的二分图中，求一个匹配使得匹配边上的权值和最大。一般X和Y集合顶点个数相同，最优匹配也是一个完备匹配，即每个顶点都被匹配。如果个数不相等，可以通过补点加0边实现转化。一般使用KM算法解决该问题。（KM（Kuhn and Munkres）算法，是对匈牙利算法的一种贪心扩展。）

==最小覆盖==：

二分图的最小覆盖分为**最小顶点覆盖**和**最小路径覆盖**：

+ 最小顶点覆盖是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联
  **注：二分图的最小顶点覆盖数=二分图的最大匹配数**
+ 最小路径覆盖也称为最小边覆盖，是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。
  **注：二分图的最小路径覆盖数=|V|-二分图的最大匹配数**

==最大独立集==：最大独立集是指寻找一个点集，使得其中任意两点在图中无对应边。对于一般图来说，最大独立集是一个NP完全问题，对于二分图来说最大独立集=|V|-二分图的最大匹配数。**最大独立集 S 与最小覆盖集 T 互补**

### 二分图判定

==概念==：如果一张图的n个节点，可以划分为两个互不相交的点集合，并且集合内没有任意两点连边。如图：

<img src="./assets/image-20230116105326067.png" alt="image-20230116105326067" style="zoom: 67%;" />

==定理==：二分图不存在奇环

​			**原因**：因为从一个集合出发走回来，肯定要在中间穿行偶数次；



==染色法判定二分图==：即尝试用两种颜色标记途中的节点，当一个点被标记后，所有与他相邻的节点应该标记与他相反的颜色，若标记过程中产生冲突，则说明图中存在奇环，可用dfs，bfs，并查集实现。

==dfs代码==

```c++
const int N = 1e5+10;
struct edge{int v,ne;}e[N];
int h[N], idx;
int color[N];
void add(int a,int b)
{
    e[++idx] = {b, h[a]};
    h[a] = idx;
}
bool dfs(int u,int c)
{
    color[u] = c;
    for(int i = h[u];i ;i =e[i].ne){
        int v=e[i].v;
        if(!color[v])
            if(dfs(v,3-c))return 1;
        else if(color[v]==c)return 1;
	}
    return 0;
}
```

==并查集代码==
$$
∫(x−x*x)^{（n+1)} dx = \frac{(x-x^2)^n} {-2n-1} - ∫\frac{n}{2n+1}* (x-x^2)^{n-1}] dx
$$


[(196条消息) 并查集判断二分图(tourist做法)_yHan234的博客-CSDN博客_并查集判断二分图](https://blog.csdn.net/Fnyiii/article/details/125781701?ops_request_misc=%7B%22request%5Fid%22%3A%22167414392616800182727533%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=167414392616800182727533&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-125781701-null-null.142^v71^one_line,201^v4^add_ask&utm_term=并查集判定环&spm=1018.2226.3001.4187)

```c++
struct DSU {  //并查集模板
    vector<int> p;
    DSU(int n) : p(n + 1) { iota(p.begin(), p.end(), 0); }
    int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); }
    void uni(int x, int y) { p[find(x)] = find(y); }
    bool same(int x, int y) { return find(x) == find(y); }
};
struct Edge { int u, v; } edge[M];
bool check(int n, int m) {
    DSU dsu(n * 2);
    for (int i = 1; i <= m; ++i) {  //合并所有边的两个端点
        int u = edge[i].u, v = edge[i].v;
        dsu.uni(u, v + n), dsu.uni(u + n, v);
    }
    for (int i = 1; i <= n; ++i)  //判断是否有i与i+n在一个集合中
        if (dsu.same(i, i + n))
            return false;
    return true;
}
```



### 二分图最大匹配-匈牙利算法

==最大匹配定义==：设二分图G，在G的子图M中，任意两条边都没有公共节点，那么称M为二分图的一组匹配，二分图G中包含边数最多的一组匹配称为二分图的最大匹配。

==交替路==：从一个**未匹配点**出发，依次经过非匹配边，匹配边，非匹配边······

形成的路径叫交替路。

==增广路==：从一个**未匹配点**出发，走交替路，若能到达另一个**未匹配点**，则这条交替路称为增广路。

==匈牙利算法==：通过不停找增广路增加匹配边，找不到增广路时，达到最大匹配，可以用dfs，bfs实现。



```c++
const int N = 1e5+10;
int n, m, k, a, b, ans;
struct edge { int v, ne; }e[N];
int h[N], idx;
int vis[N], match[N];
void add(int a, int b) {
	e[++idx] = { b,h[a] };
	h[a] = idx;
}
bool dfs(int u)
{
	for (int i = h[u]; i; i = e[i].ne)
	{
		int v = e[i].v;
		if (vis[v])continue;//标记已经固定的节点
		vis[i] = 1;
		if(!match[v]||dfs(match[v])){
			match[v] = u;
			return 1;
		}
	}
	return 0;
}
signed main()
{
	IO;
	cin >> n >> m >> k;
	for (int i = 0; i < k; i++)//只记录从左向右的连边
		cin >> a >> b, add(a, b);
	for (int i = 1; i <= n; i++)
	{
		memset(vis, 0, sizeof vis);//每次清空标记数组
		if (dfs(i))ans++;
	}

	cout << ans;
	return 0;
}
```

### 最大权匹配KM算法

```c++
int va[500], vb[500];
int n;
int la[500], lb[500];
int d[500];
int match[500], w[25][25];
bool dfs(int x)
{
    va[x] = 1;
    for (int y = 1; y <= n; y++)
    {
        if (!vb[y]) {
            if (la[x] + lb[y] == w[x][y]) {
                vb[y] = 1;
                if (!match[y] || dfs(match[y]))
                {
                    match[y] = x;
                    return 1;
                }
            }
            else
                d[y] = min(d[y], la[x] + lb[y] - w[x][y]);
        }
    }
    return 0;
}
ll KM()
{
    for (int i = 1; i <= n; i++) la[i] = -oo;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            la[i] = max(la[i], w[i][j]);

    for (int i = 1; i <= n; i++) lb[i] = 0;
    for (int i = 1; i <= n; i++)
    {
        while (true)
        {
            fill(va + 1, va + 1 + n, 0);
            fill(vb + 1, vb + 1 + n, 0);
            fill(d + 1, d + 1 + n, 0);
            if (dfs(i))break;
            ll delta = -oo;
            for (int j = 1; j <= n; j++)
                if (!vb[j]) delta = min(delta, d[j]);
            for (int j = 1; j <= n; j++)
            {
                if (va[j]) la[j] -= delta;
                if (vb[j]) lb[j] += delta;
            }
        }
    }
}
```

## 网络流

==网络==：表示一个有向图$G=(V,E)$，有两个特殊节点，**源点S**和**汇点T**，

> $c(x,y)$

每条有向边$(x,y ) \in E$，都有一个权值$c(x,y)$，称为边的**容量**，若$(x,y) \notin E$，则$c(x,y)=0$

> $f(x,y)$

$f(x,y)$表示边上$(x,y)$的流量，$c(x,y)-f(x,y)$称为边的剩余容量

通常用$f(x,y)/c(x,y)$标记边上的流量和容量

==可行流==：表示一个从源点S到达汇点T的一个路径，路径上的边的剩余容量大于等于零

+ **容量限制**：$f(x,y)<=c(x,y)$
+ **流量守恒**：$\sum_{\substack{(u,x) \in E}}f(u,x)=\sum{\substack{(x,v) \in E}}f(x,v), \ x\ne S, \ x\ne T$

==最大流==：从源点到汇点的最大流量

==增广路==：一条从源点到达汇点的所有边的剩余容量$\ge0$的路径

==残留网==：从网络中所有节点和剩余容量大于0的边构成的子图，此处的边包含有向边和构建的反向边

+ **反向边**在建图的过程中初始化建立，和有向边成对存在，反向边初始容量为0
+ 反向边的目的就是为了找到增广路，提供一种**退流机制**

### 最大流EK算法

```c++
struct node {
	ll v, c, ne;// v:链接的点，c:边容量, ne:后继节点
}e[N];
int h[N], idx = 1;
ll mf[N];// 以v结尾的边的容量上限
ll pre[N];// v的前驱边
int S, T;//源点，汇点
void add(int u, int v, int c)
{
    e[++idx] = {v, c, h[u]};
    h[u] = idx;
}
bool bfs()
{
    memset(mf, 0, sizeof mf);
    queue<int> q;
    q.push(S); mf[S] = 1e9;
    while(q.size())
    {
        int u = q.front();
        q.pop();
        for(int i = h[u];i;i = e[i].ne)
        {
            ll v = e[i].v;
            if(mf[v] == 0 && e[i].c)
            {
                mf[v] = min(mf[u], e[i].c);
                pre[v] = i;
                q.push(v);
                if(v == T)return true;
            }
        }
    }
    return false;
}

ll EK()
{
    ll flow = 0;
    while(bfs())
    {
        int v = T;
        while(v != S)
        {
            int i = pre[v];
            e[i].c -= mf[T];
            e[i ^ 1].c += mf[T];
            v = e[i ^ 1].v;
        }
        flow += mf[T];
    }
    return flow;
}
//建图注意同步建立反向边，切记
signed main(){ IO;
	cin >> n >> m >> S >> T;
	for(int i = 1;i <= m;i ++)
	{
		int u, v, w;
		cin >> u >> v >> w;
		add(u, v, w);
		add(v, u, 0);// 建反边
	}
	cout << EK();

	return 0;
}
```

### Dinic最大流

```c++
#include <bits/stdc++.h>
#define ll long long
#define IO ios::sync_with_stdio(false);cin.tie(nullptr)
#define int ll
const int N = 2e5 + 10, M = 2 * N;
using namespace std;
struct node {
	ll v, c, ne;// v:链接的点，c:边容量, ne:后继节点
}e[N];
ll n, m, s, t;
ll h[N], idx = 1;
ll d[N] = { 0 }, cur[N];// 当前弧优化
int S, T;//源点，汇点
void add(int u, int v, int c)
{
	e[++idx] = { v, c, h[u] };
	h[u] = idx;
}
bool bfs()
{
	memset(d, 0, sizeof d);
	queue<int> q;
	q.push(S);
	d[S] = 1;
	while (q.size())
	{
		int u = q.front(); q.pop();
		for (int i = h[u]; i; i = e[i].ne)
		{
			ll v = e[i].v;
			if (d[v] == 0 && e[i].c)
			{
				d[v] = d[u] + 1;
				q.push(v);
				if (v == T)return true;
			}
		}
	}
	return false;
}
ll dfs(ll u, ll mf)
{
	if (u == T) return mf;
	ll sum = 0;
	for (int i = cur[u]; i; i = e[i].ne)
	{
		cur[u] = i;
		ll v = e[i].v;
		if (d[v] == d[u] + 1 && e[i].c)
		{
			ll f = dfs(v, min(mf, e[i].c));
			e[i].c -= f;
			e[i ^ 1].c += f;
			sum += f;
			mf -= f;
			if (mf == 0)break;
		}
	}
	if (sum == 0) d[u] = 0;
	return sum;
}
ll dinic()
{
	ll flow = 0;
	while (bfs()) {
		memcpy(cur, h, sizeof h);
		flow += dfs(S, 1e9);
	}
	return flow;
}
//建图注意同步建立反向边，切记
signed main() {
	IO;
	cin >> n >> m >> S >> T;
	for (int i = 1; i <= m; i++)
	{
		int u, v, w;
		cin >> u >> v >> w;
		add(u, v, w);// 这里不考虑是否存在重边
		add(v, u, 0);
	}
	cout << dinic();

	return 0;
}
```

**最大流最小割定理**

$f(s, t)_{max} = c(s, t)_{min}$

**证明：**假设最小割$<$最大流，

```c++
int vis[N] = {0}, idx = 1;
void mincut(int u){
    vis[u] = 1;
    for(int i = h[i];i;i = e[i].ne)
    {
        int v = e[i].v;
        if(!vis[v] && e[i].c)
            mincut(v);
    }
}
int main(){
    cin >> n >> m >> S >> T;
    for(int i = 1;i <= m;i ++)
    {
        cin >> a[i] >> b[i] >> w[i];
        add(a[i], b[i], w[i]);
        add(b[i], a[i], 0);
    }
    cout << dinic();
    mincut(S);
    for(int i = 1;i <= n;i ++)
        if(vis[i])cout << i << ' ';
    cout << endl;
    for(int i = 1;i <= n;i ++)
        if(!vis[i])cout << i << ' ';
    cout << endl;
    idx = 1;
    memset(h, 0, sizeof h);
    for(int i = 1;i <= m;i ++)
    {
        add(a[i], b[i], 1);
        add(b[i], a[i], 0);
    }
    cout << dinic();
}
```



**费用流**



### 费用流EK算法

```c++
struct node {
    ll v, c, w, ne;
}e[N];
int h[N], idx = 1;
ll mf[N];// 以v结尾的边的容量上限
ll pre[N];// v的前驱边
ll cost, flow, d[N], vis[N];
int n, m, S, T;//源点，汇点

void add(int u, int v, int c, int w)
{
    e[++idx] = {v, c, w, h[u]};
    h[u] = idx;
}
bool spfa()
{
    memset(d, 0x3f, sizeof d);
    memset(mf, 0, sizeof mf);
    queue<int> q; q.push(S);
    d[S] = 0; mf[S] = oo, vis[S] = 1;
    while(q.size()){
        int u = q.front();q.pop();vis[u] = 0;
        for(int i = h[u];i;i = e[i].ne)
        {
            int v = e[i].v, w = e[i].w, c = e[i].c;
            if(d[v] > d[u] + w && c)
            {
                d[v] = d[u] + w;
                mf[v] = min(mf[u], c);
                pre[v] = i;
                if(!vis[v])
                {
                    q.push(v);vis[v] = i;
                }
            }
        }
    }
    return mf[T] > 0;
}
void EK()
{
	cost = flow = 0;
    while(spfa())
    {
        int v = T;
        while(v!=S)
        {
            int i = pre[v];
            e[i].c -= mf[T];
            e[i^1].c += mf[T];
            v = e[i^1].v;
        }
        flow += mf[T];
        cost += mf[T] * d[T];
    }
}
//建图注意同步建立反向边，切记
signed main() {
	IO;
	cin >> n >> m >> S >> T;
	for (int i = 1; i <= m; i++)
	{
		int u, v, c, w;// u 向 v 链接一条容量为 c 单位流价格为 w 的边
		cin >> u >> v >> c >> w;
		add(u, v, c, w);// 这里不考虑是否存在重边
		add(v, u, 0, -w);
	}
	EK();
	cout << flow << " " << cost << endl;
	return 0;
}
```



## splay

==作用==

+ 插入x数
+ 删除x数，若有多个相同的数，则只删除一个
+ 查询x数的排名，排名定义为比当前数小的数的个数
+ 查询排名为x的数
+ 求x的前驱，即小于x的最大数
+ 求x的后继，即大于x的最小数

```c++
struct node {
    //左右儿子、父节点、节点权值、权值出现次数、子树大小
    int s[2];// 0 表示左儿子，1 表示右儿子
    int p, v, cnt, size;
    void init(int p1, int v1)
    {
        p = p1, v = v1;
        cnt = size = 1;
    }
}tr[N];
int root;// 根节点编号
int idx;//节点个数，对节点进行编号

void pushup(int x)//更新子树大小
{
    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size
        + tr[x].cnt;
}

void rotate(int x)//将x进行旋转操作，使得x向上移动
{
    int y = tr[x].p, z = tr[y].p;
    int k = (tr[y].s[1] == x);

    tr[y].s[k] = tr[x].s[k ^ 1];
    tr[tr[x].s[k ^ 1]].p = y;

    tr[x].s[k ^ 1] = y;
    tr[y].p = x;

    tr[z].s[tr[z].s[1] == y] = x;
    tr[x].p = z;

    pushup(y), pushup(x);
}

void splay(int x, int k)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
        {
            if (tr[y].s[0] == x ^ tr[z].s[0] == y)
                rotate(x);
            else
                rotate(y);
        }
        rotate(x);
    }
    if (k == 0) root = x;
}

void find(int v)//找到点权最接近 v 的节点
{
    int x = root;
    while (tr[x].s[v > tr[x].v] && v != tr[x].v)
        x = tr[x].s[v > tr[x].v];
    splay(x, 0);
}

int get_pre(int v)
{
    find(v);//找到v的前驱
    int x = root;
    if (tr[x].v < v) return x;
    x = tr[x].s[0];
    while (tr[x].s[1]) x = tr[x].s[1];
    return x;
}

int get_suc(int v)
{
    find(v);
    int x = root;
    if (tr[x].v > v) return x;
    x = tr[x].s[1];
    while (tr[x].s[0]) x = tr[x].s[0];
    return x;
}

void del(int v)
{
    int pre = get_pre(v);
    int suc = get_suc(v);
    splay(pre, 0), splay(suc, pre);
    int del = tr[suc].s[0];
    if (tr[del].cnt > 1)
        tr[del].cnt--, splay(del, 0);
    else
        tr[suc].s[0] = 0, splay(suc, 0);
}

int get_rank(int v)
{
    find(v);
    return tr[tr[root].s[0]].size;
}

int get_val(int k)
{
    int x = root;
    while (1) {
        int y = tr[x].s[0];
        if (tr[y].size + tr[x].cnt < k) {
            k -= tr[y].size + tr[x].cnt;
            x = tr[x].s[1];
        }
        else {
            if (tr[y].size >= k) x = tr[x].s[0];
            else break;
        }
    }
    splay(x, 0);
    return tr[x].v;
}

void insert(int v)
{
    int x = root, p = 0;
    while (x && tr[x].v != v)
        p = x, x = tr[x].s[v > tr[x].v];
    if (x) tr[x].cnt++;
    else {
        x = ++idx;
        tr[p].s[v > tr[p].v] = x;
        tr[x].init(p, v);
    }
    splay(x, 0);
}
signed main()
{
    insert(-1e9); insert(1e9);
    cin >> n;
    while(n--)
    {
        int op;cin >> op;
        int x; cin >> x;
        if(op == 1) insert(x);
        if(op == 2) del(x);
        if(op == 3)cout << get_rank(x) << endl;
        if(op == 4)cout << get_val(x + 1) << endl;
        if(op == 5)cout << tr[get_pre(x)].v << endl;
        if(op == 6)cout << tr[get_suc(x)].v << endl;
    }
    return 0;
}
```



# 字符串

## KMP

```c++
int ne[N];
char p[N],q[N];//主串，模式串
int n, m;//主串长度，模式串长度
int get_ne()//获取最大前缀数组(模式串)
{
	for (int i = 2, j = 0; i <= n; i++)//注意KMP算法对于字符串的下标从1开始
	{
		while (j && p[i] != p[j + 1])
            j = ne[j];
		if (p[j + 1] == p[i])
            j++;
		ne[i] = j;
	}
}
int pipei(){
    for(int i = 1, j = 0;i <= n;i ++)
    {
        while(j && p[i] != q[j + 1]) j = ne[j];
        if(p[i] == q[j + 1]) j ++;
        if(j == m) cout << i - m + 1;
    }    
    	
}
int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> p[i];
	for (int i = 1; i <= m; i++)
		cin >> q[N];
	return 0;
}
```

## 扩展KMP

==Z函数==

对于一个长度为 $n$ 的字符串 $S$。$z[i]$ 表示为 $S$ 与其后缀 $S[i, n]$ 的最长公共前缀 $(LCP)$的长度。



```c++
const int N = 1e5 + 10;
int z[N], p[N];
void get_z(string s, int n){//相同字符串之间的扩展kmp
    z[1] = n;
    for(int i = 2, l, r = 0;i <= n;i ++)
    {
        if(i <= r) z[i] = min(r - i + 1, z[i - l + 1]);
        while(s[z[i] + 1] == s[i + z[i]]) z[i] ++;
        if(i + z[i] - 1 > r) r = i + z[i] - 1, l = i; 
    }
}
void get_p(string t, int n, int m)// 不同字符串之间的扩展kmp
{
    for(int i = 1, l, r = 0;i <= m;i ++)
    {
        if(i <= r) p[i] = min(r - i + 1, z[i - l + 1]);
        while(1 + p[i] <= n && i + p[i] <= m && s[1 + p[i]] == t[i + p[i]])
            p[i] ++;
        if(i + p[i] - 1 > r) r = i + p[i] - 1, l = i;
    }
}
```

## AC自动机

用于多模式串匹配，给定 $n$ 个模式串和一个主串，查找有多少个模式串在主串种出现过。

+ 先构造一个 $tire$ 树
+ 在 $tire$ 树上建立两类边：**回跳边**和**转移边**

​		回跳边：指向父节点的回跳边所指节点的儿子

​		

+ 扫描主串匹配即可

```c++
//建立 tire 树
const int N = 1e5 + 10;
int ch[N][30], cnt[N], idx;
int ne[N];//存储节点 i 的回跳边的终点，
void insert(string s){
    int p = 0;
    for(int i = 0;i < s.size();i ++)
    {
        int j = s[i] - 'a';
        if(!ch[p][j]) ch[p][j] = ++idx;
        p = ch[p][j];
    }
    cnt[p] ++;
}
void build(){//建立AC自动机
    queue<int> q;
    for(int i = 0;i < 26;i ++)
    	if(ch[0][i]) q.push(ch[0][i]);
    while(q.size())
    {
    	int u = q.front();q.pop();
        for(int i = 0;i < 26;i ++)
        {
            int v = ch[u][i];
            if(v) ne[v] = ch[ne[u]][i], q.push(v);
            else ch[u][i] = ch[ne[u]][i];
        }
	}
}
int query(string s)
{
    int ans = 0;
    for(int k = 0, i = 0;s[k]; k ++)
    {
        i = ch[i][s[k] - 'a'];
        for(int j = i;j && ~cnt[j];j = ne[j])//如果是求累计总共出现多少次，要将 ~cnt[j] 和 cnt[j] = -1， 两个条件删去
            ans += cnt[j], cnt[j] = -1;
    }
    return ans;
}
```



## 字符串哈希

```c++
const unsigned ll Prime = 13331;
string s; cin >> s;
unsigned ll k = 0;
for (int i = 0; i < s.size(); i++)
{
    k = k * Prime + (unsigned ll)s[i];
}
```

## 最大异或对

<img src="C:\Users\王雄\AppData\Roaming\Typora\typora-user-images\image-20220904164338904.png" alt="image-20220904164338904" style="zoom: 50%;" />

```c++
const int N = 100007;
int q[31*N][2];
int dix = 0;
void insert(int x)
{
	int p = 0;
	for (int i = 32; i >= 0; i--)
	{
		int j = x >> i & 1;
		if (!q[p][j])q[p][j] = ++dix;
		p = q[p][j];
	}
}

int query(int x)
{
	int  p = 0, res = 0;
	for (int i = 32; i >= 0; i--)
	{
		int j = x >> i & 1;
		if (q[p][!j]) {
			res += 1ll << i;
			p = q[p][j];
		}
		else
			p = q[p][j];
	}
	return res;
}

```

## Tire==字典树==

```c++
//建树
const int N = 1e5;
int trie[N][26], cnt[N], idx;
string s; cin>>s;
void insert(string & s)
{
    int p = 0;
    for(int i = 0; i < s.size(); i ++)
    {
        int j = s[i] - 'a';
        if(!trie[p][j]) trie[p][j] = ++idx;
        p = trie[p][j];
    }
    cnt[p] ++;
}

// 查询
int query(string & s)
{
    int p = 0;
    for(int i = 0; i <= s.size(); i ++)
    {
        int j = s[i] - 'a';
        if(!trie[p][j]) return false;
        p = trie[p][j];
    }
    return true;
}

//清空字典树
for(int i = 0;i <= idx;i ++)
    memset(trie, 0, sizeof trie[i]);
```

# 板子

## 波兰表达式

```c++
#include<iostream>
#include<cstring>
 
using namespace std;
 
double p(){
	string str;
	cin >> str;
	switch (str[0]){
	  case '+': return p() + p();
	  case '-': return p() - p();
	  case '*': return p() * p();
	  case '/': return p() / p();
	  default:
	  	return stof(str);
	}
}
 
int main(){
    printf("%f\n", p());
	return 0;
}
```



## 线段树

例题：https://atcoder.jp/contests/abc278/tasks/abc278_d

```c++
#define lc p<<1
#define rc p<<1|1
int n, w[N];

struct node {
	int l, r, sum,a, laz;
}tr[N * 4];//尤其注意节点数组数量扩大个4倍

void build(int p, int l, int r) {
	tr[p] = { l,r,w[l] ,0 };
	if (l == r)
		return;
	int mid = tr[p].l + tr[p].r >> 1;
	build(lc, l, mid), build(rc, mid + 1, r);
	tr[p].sum = tr[lc].sum + tr[rc].sum;
}

void pushdown(int p)
{
	if (tr[p].laz) {
		tr[lc].sum += (tr[lc].r - tr[lc].l + 1) * tr[p].laz;
		tr[rc].sum += (tr[rc].r - tr[rc].l + 1) * tr[p].laz;
		tr[lc].laz += tr[p].laz;
		tr[rc].laz += tr[p].laz;
		tr[p].laz = 0;
	}
}

void update(int p, int x, int k) {//点修改
	if (tr[p].l == x && tr[p].r == x)
	{
		tr[p].sum += k;
		return;
	}
	pushdown(p);
	int mid = tr[p].l + tr[p].r >> 1;
	if (x <= mid)
		update(lc, x, k);
	else
		update(rc, x, k);
	tr[p].sum = tr[lc].sum + tr[rc].sum;
}

int query(int p, int x, int y) {
	if (x <= tr[p].l && tr[p].r <= y) {
		return tr[p].sum;
	}
	int sum = 0;
	pushdown(p);
	int mid = tr[p].l + tr[p].r >> 1;
	if (x <= mid)
		sum += query(lc, x, y);
	if (y > mid)
		sum += query(rc, x, y);
	return sum;
}
```

## 动态开点

```c++
struct node{
    int l, r, sum, laz;//左儿子右儿子下标
}tr[N*2];
//开点
int tot = 0;
int build() {
	tot++;
	tr[tot].l = tr[tot].r = tr[tot].sum = tr[tot].laz = 0;
	return tot;
}
 
void pushdown(int p, int l, int r)
{
	if (!tr[p].l)tr[p].l = build();
	if (!tr[p].r)tr[p].r = build();
	int lc = tr[p].l, rc = tr[p].r;
	int mid = l + r >> 1;
	if (tr[p].laz) {
		tr[lc].sum += (mid - l + 1) * tr[p].laz;
		tr[rc].sum += (r - mid) * tr[p].laz;
		tr[lc].laz += tr[p].laz;
		tr[rc].laz += tr[p].laz;
		tr[p].laz = 0;
	}
}
 
void insert(int p, int l, int r, int x,int y, int delta)
{
	if (l >= x && r <= y)
	{
		tr[p].sum += (r - l + 1) * delta;
		tr[p].laz += delta;
		return;
	}
	pushdown(p, l, r);
	int mid = l + r >> 1;
	if (x <= mid)
	{
		if (!tr[p].l)tr[p].l = build();
		insert(tr[p].l, l, mid, x, y, delta);
	}
	if (y > mid)
	{
		if (!tr[p].r)tr[p].r = build();
		insert(tr[p].r, mid + 1, r, x, y, delta);
	}
	tr[p].sum = max(tr[tr[p].l].sum, tr[tr[p].r].sum);
}
 
int query(int p, int l, int r, int idx)
{
	if (l == r) {
		return tr[p].sum;
	}
	pushdown(p, l, r);
	int mid = l + r >> 1;
	int sum = 0;
	if (idx <= mid)
		sum = query(tr[p].l, l, mid, idx);
	if (idx > mid)
		sum = query(tr[p].r, mid + 1, r, idx);
	return sum;
}
```

## 持久化线段树+动态开点

```c++
#include <bits/stdc++.h>
#define ll long long
#define IO ios::sync_with_stdio(false);cin.tie(nullptr)
#define endl "\n"
#define int ll
const int N = 2e5 + 10, M = 2 * N;
using namespace std;

#define lc(x) tr[x].ch[0]
#define rc(x) tr[x].ch[1]

int n, m;
vector<int> v;
struct node {//权值线段树，每个节点存储其所代表的区间内值的个数
	int ch[2];//左右儿子
	int s;//值域内数的个数
}tr[N*30];
int root[N], idx;//第几个版本根节点, 节点下标
void build(int& x, int l, int r) {//
	x = ++idx;
	if (l == r)return;
	int mid = l + r >> 1;
	build(lc(x), l, mid);
	build(rc(x), mid + 1, r);
}
// x 上一版本的根节点编号，y当前版本根节点编号，l，r为权值线段树范围，v为插入值
void insert(int x, int& y, int l, int r, int v) {
	y = ++idx; tr[y] = tr[x]; tr[y].s++;
	if (l == r)return;
	int mid = l + r >> 1;
	if (v <= mid) insert(lc(x), lc(y), l, mid, v);
	else insert(rc(x), rc(y), mid + 1, r, v);
}
int query(int x, int y, int l, int r, int k)
{
	if (l == r)return l;
	int mid = l + r >> 1;
	int s = tr[lc(y)].s - tr[lc(x)].s;
	if (k <= s)return query(lc(x), lc(y), l, mid, k);
	else return query(rc(x), rc(y), mid + 1, r, k - s);
}
//离散化获取下标，
int getid(int x)
{
    //加一使得下标从1开始
	return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;
}
signed main()
{
	IO;
	int n, m; cin >> n >> m;

	build(root[0], 1, n);
	for (int i = 1; i <= n; i++)
	{
		int x; cin >> x;
		v.push_back(x);
	}

	auto vv = v;
	sort(all(v));
	v.erase(unique(all(v)), v.end());
	for(int i = 1;i<=n;i++)
		insert(root[i - 1], root[i], 1, n, getid(vv[i - 1]));
	
	vector<array<int, 3>> q;
	for (int i = 1; i <= m; i++) {
		int l, r;
		cin >> l >> r;
		int x; cin >> x;
		q.push_back({ l,r,x });
	}
	for (int i = 0; i < m; i++)
	{
		int ans = query(root[q[i][0] - 1], root[q[i][1]], 1, n, q[i][2]);
		cout << v[ans-1] << endl;
	}

	return 0;
}
```

## 可持久化数组

```c++
#include <bits/stdc++.h>
#define lc(x) tr[x].ch[0]
#define rc(x) tr[x].ch[1]
#define ll long long
#define IO ios::sync_with_stdio(false);cin.tie(nullptr)
#define endl "\n"
#define int ll
const int N = 1e6 + 10, M = 2 * N;
using namespace std;

int n, m, a[N];
struct node {
    int ch[2];
    int v;
}tr[N * 25];
int root[N], idx;
void build(int& x, int l, int r) {
    x = ++idx;
    if (l == r) { tr[x].v = a[l]; return; }
    int mid = l + r >> 1;
    build(lc(x), l, mid), build(rc(x), mid + 1, r);
}
void modify(int& x, int y, int l, int r, int pos, int val)
{
    x = ++idx;
    tr[x] = tr[y];
    if (l == r) { tr[x].v = val; return; }
    int mid = l + r >> 1;
    if (pos <= mid) modify(lc(x), lc(y), l, mid, pos, val);
    else modify(rc(x), rc(y), mid + 1, r, pos, val);
}

int query(int x, int l, int r, int pos) {
    if (l == r)
        return tr[x].v;
    int mid = l + r >> 1;
    if (pos <= mid) return query(lc(x), l, mid, pos);
    else return query(rc(x), mid + 1, r, pos);
}
signed main()
{
    IO;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)cin >> a[i];
    build(root[0], 1, n);
    int cnt = 0;
    while (m--) {
        int v; cin >> v;
        int op; cin >> op;
        if (op == 1)
        {
            int pos, val; cin >> pos >> val;
            modify(root[++cnt], root[v], 1, n, pos, val);
        }
        else
        {
            int pos; cin >> pos;
            int ans = query(root[v], 1, n, pos);
            cout << ans << endl;
            modify(root[++cnt], root[v], 1, n, pos, ans);
        }
    }
    return 0;
}
```



## 吉司机线段树

```c++

#include <bits/stdc++.h>
#define oo 0x3f3f3f3f
#define ll long long
#define IO ios::sync_with_stdio(0);cin.tie(0)
#define rep(i,a,n) for (ll i=a;i<=n;i++)
#define per(i,a,n) for (ll i=a;i>=n;i--)
const int N = 2e5 + 10, M = 2 * N;
using namespace std;
typedef pair<ll, ll>  pll;
typedef pair<int, int> pii;
#define deb(i,x) if(int i==x) int k = 1; 
#define  pb push_back
#define all(x) x.begin(),x.end()
ll lowbit(ll x) { return x & -x; }
ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
ll qmi(ll a, ll b, ll mod) {
	ll res = 1; while (b) { if (b & 1) res = res * a % mod; a = a * a % mod; b >>= 1; }
	return res;
}
#define int ll
#define lc p<<1
#define rc p<<1|1
int n, a[N];

struct node {
	int l, r, ma, se, cnt, sum;
}tr[N * 4];//尤其注意节点数组数量扩大个4倍

void pushdown(int p)
{
	if (tr[lc].ma > tr[p].ma)
	{
		tr[lc].sum -= (tr[lc].ma - tr[p].ma) * tr[lc].cnt;
		tr[lc].ma = tr[p].ma;
	}
	if (tr[rc].ma > tr[p].ma)
	{
		tr[rc].sum -= (tr[rc].ma - tr[p].ma) * tr[rc].cnt;
		tr[rc].ma = tr[p].ma;
	}
}

void pushup(int p)
{
	tr[p].sum = tr[lc].sum + tr[rc].sum;
	tr[p].cnt = 0;
	tr[p].ma = max(tr[lc].ma, tr[rc].ma);
	if (tr[lc].ma == tr[rc].ma)
	{
		tr[p].cnt = tr[lc].cnt + tr[rc].cnt;
		tr[p].se = max(tr[lc].se, tr[rc].se);
	}
	else
	{
		if (tr[lc].ma < tr[rc].ma)
		{
			tr[p].se = max(tr[lc].se, tr[lc].ma);
			tr[p].cnt = tr[rc].cnt;
		}
		else
		{
			tr[p].se = max(tr[lc].ma, tr[rc].se);
			tr[p].cnt = tr[lc].cnt;
		}
	}
}


void build(int p, int l, int r) {

	if (l == r)
	{
		tr[p] = { l,r,a[l],-1,1,a[l] };
	}
	else
	{
		tr[p].l = l, tr[p].r = r;
		int mid = tr[p].l + tr[p].r >> 1;
		build(lc, l, mid), build(rc, mid + 1, r);
		tr[p].sum = tr[lc].sum + tr[rc].sum;
		pushup(p);
	}
}


void query1(int p, int l, int r, int x)
{
	if (tr[p].ma <= x)return;
	if (l >= tr[p].l && r <= tr[p].r && tr[p].se < x)
	{
		tr[p].sum -= (tr[p].ma - x) * tr[p].cnt;
		tr[p].ma = x;
		return;
	}
	pushdown(p);
	int mid = tr[p].l + tr[p].r >> 1;
	if (l <= mid)query1(lc, l, r, x);
	if (r > mid)query1(rc, l, r, x);
	pushup(p);
}

int query2(int p, int l, int r)
{
	if (l >= tr[p].l && r <= tr[p].r)
	{
		return tr[p].ma;
	}
	pushdown(p);
	int res = 0;
	int mid = tr[p].l + tr[p].r >> 1;
	if (l <= mid)
		res = max(res, query2(lc, l, r));
	if (r > mid)
		res = max(res, query2(rc, l, r));
	return res;
}

int query3(int p, int l, int r) {
	if (l <= tr[p].l && tr[p].r <= r) {
		return tr[p].sum;
	}
	int sum = 0;
	pushdown(p);
	int mid = tr[p].l + tr[p].r >> 1;
	if (l <= mid)
		sum += query3(lc, l, r);
	if (r > mid)
		sum += query3(rc, l, r);
	return sum;
}

signed main()
{
	IO;
	int n; cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	build(1, 1, n);
	int q; cin >> q;
	while (q--) {
		int op; cin >> op;
		if (op == 1) {

		}
		else if (op == 2) {

		}
		else
		{

		}
	}

	return 0;
}
```



## 高精度

```c++
#include <bits/stdc++.h>
using i64 = long long;

bool relat(std::string& a, std::string& b) {
	if (a.size() != b.size()) return a.size() > b.size();
	for (int i = 0; i < int(a.size()); i++) {
		if (a[i] != b[i]) return a[i] > b[i];
	}
	return true;
}

string add(std::string a, int num) {
	std::string c;
	string b;
	while (num) { b += num % 10 + '0'; num /= 10; }

	bool ok = true;
	if (!relat(a, b)) std::swap(a, b);
	reverse(a.begin(), a.end());
	int d = a.size() - b.size(); b += string(d, '0');
	int p = 0;
	for (int i = 0; i < int(a.size()); i++) {
		p = a[i] - '0' + b[i] - '0' + p;
		c += p % 10 + '0';
		p /= 10;
	}
    if(p) c += p + '0';
	while (c.size() > 1 && c.back() == '0') c.pop_back();
	if (ok) reverse(c.begin(), c.end());
	else reverse(c.begin() + 1, c.end());
	return c;
}

std::string operator^(std::string a, std::string b) {
	std::string c;
	reverse(a.begin(), a.end());
	reverse(b.begin(), b.end());
	int p = 0;
	for (int i = 0; i < int(a.size()) || i < int(b.size()); i++) {
		if (i < int(a.size())) p += a[i] - '0';
		if (i < int(b.size())) p += b[i] - '0';
		c += p % 10 + '0', p /= 10;
	}
	if (p) c += p + '0';
	reverse(c.begin(), c.end());
	return c;
}

std::string operator-(std::string a, std::string b) {
	std::string c;
	bool ok = true;
	if (!relat(a, b)) std::swap(a, b), ok = false, c += '-';
	reverse(a.begin(), a.end());
	reverse(b.begin(), b.end());
	int p = 0;
	for (int i = 0; i < int(a.size()); i++) {
		p = a[i] - '0' - p;
		if (i < int(b.size())) p -= b[i] - '0';
		c += ((p + 10) % 10) + '0';
		if (p < 0) p = 1;
		else p = 0;
	}
	while (c.size() > 1 && c.back() == '0') c.pop_back();
	if (ok) reverse(c.begin(), c.end());
	else reverse(c.begin() + 1, c.end());
	return c;
}
string operator*(std::string a, ll b) {
	string c;
	reverse(a.begin(), a.end());
	ll p = 0;
	for (int i = 0; i < int(a.size()) || p; i++) {
		if (i < int(a.size())) p += (a[i] - '0') * b;
		c += p % 10 + '0', p /= 10;
	}
	while (c.size() > 1 && c.back() == '0') c.pop_back();
	reverse(c.begin(), c.end());
	return c;
}
std::string operator/(std::string a, i64 b) {
	std::string c;
	i64 r = 0;
	for (int i = 0; i < int(a.size()); i++) {
		r = r * 10 + a[i] - '0';
		c += r / b + '0', r %= b;
	}
	reverse(c.begin(), c.end());
	while (c.size() > 1 && c.back() == '0') c.pop_back();
	reverse(c.begin(), c.end());
	return c;
}

std::string operator%(std::string a, i64 b) {
	std::string c;
	i64 r = 0;
	for (int i = 0; i < int(a.size()); i++) {
		r = r * 10 + a[i] - '0';
		c += r / b + '0', r %= b;
	}
	reverse(c.begin(), c.end());
	while (c.size() > 1 && c.back() == '0') c.pop_back();
	reverse(c.begin(), c.end());
	return std::to_string(r);
}
#define to(a) #a
```

## 并查集

```c++
struct DSU {
    std::vector<int> f, siz;
    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }
    int leader(int x) {
        while (x != f[x]) x = f[x] = f[f[x]];
        return x;
    }
    bool same(int x, int y) { return leader(x) == leader(y); }
    bool merge(int x, int y) {
        x = leader(x);
        y = leader(y);
        if (x == y) return false;
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
    int size(int x) { return siz[leader(x)]; }
};
```

## 矩阵

```c++
struct Matrix {//矩阵初始化，乘法重载
	vector<vector<int>> a(100,);
	Matrix()
	{
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < m; j++) {
				a[i][j] = 0;
			}
		}
	}
	Matrix operator * (const Matrix& Ma_) const
	{
		Matrix res;
		for (int i = 0; i < m; ++i) {
			for (int j = 0; j < m; ++j) {
				for (int k = 0; k < m; ++k) {
					res.a[i][j] = (res.a[i][j] + a[i][k] * Ma_.a[k][j] % mod) % mod;
				}
			}
		}
		return res;
	}
};
Matrix quickpow(Matrix res,Matrix sta, ll b)//快速幂板子
{
    while (b > 0)
    {
        if (b & 1) res = res * sta;
        sta = sta * sta;
        b >>= 1;
    }
    return res;
}
```



## 向量函数

```c++
using T = double;
struct Point {
    T x;
    T y;
    Point(T x = 0, T y = 0) : x(x), y(y) {}
     
    Point &operator+=(const Point &p) {
        x += p.x, y += p.y;
        return *this;
    }
    Point &operator-=(const Point &p) {
        x -= p.x, y -= p.y;
        return *this;
    }
    Point &operator*=(const T &v) {
        x *= v, y *= v;
        return *this;
    }
    friend Point operator-(const Point &p) {
        return Point(-p.x, -p.y);
    }
    friend Point operator+(Point lhs, const Point &rhs) {
        return lhs += rhs;
    }
    friend Point operator-(Point lhs, const Point &rhs) {
        return lhs -= rhs;
    }
    friend Point operator*(Point lhs, const T &rhs) {
        return lhs *= rhs;
    }
};
 
T dot(const Point &a, const Point &b) {
    return a.x * b.x + a.y * b.y;
}
 
T cross(const Point &a, const Point &b) {
    return a.x * b.y - a.y * b.x;
}
```

## 整数取模

```c++
using i64 = long long;

int norm(int x) {
    if (x < 0) {
        x += P;
    }
    if (x >= P) {
        x -= P;
    }
    return x;
}
template<class T>
T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
struct Z {
    int x;
    Z(int x = 0) : x(norm(x)) {}
    Z(i64 x) : x(norm(x % P)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(norm(P - x));
    }
    Z inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = i64(x) * rhs.x % P;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &operator>>(std::istream &is, Z &a) {
        i64 v;
        is >> v;
        a = Z(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) {
        return os << a.val();
    }
};
```



# lamda函数

```c++
//单层匿名函数
auto f=[](int a,int b)->int {//auto类型自动识别，将匿名函数抽象为一								直类型 后面可以用f代替
    return a+b;
};

//嵌套匿名函数，(函数式编程)
auto f=[](int n)->int {
    return [n](int x)->int {//[n]捕获外层匿名函数的参数n
   		 return x+n;
	};
};
```



# 手写hash表

一般题目有百万级的哈希表插入操作，就需要手写hash表，否则超时

[4611. 串联数字 - AcWing题库](https://www.acwing.com/problem/content/4614/)

```c++
typedef long long LL;
const int N = 200010, M = 10000007;
LL h[M];
int cnt[M]={0};

int find(int x, int y)
{
    LL key = x * 100ll + y;
    LL k = key % M;
    while (h[k] != -1 && h[k] != key)//遇到空的hash表位置或者遇到相同的key值退出
        if (++k == M)
            k = 0;
    if (h[k] == -1)
        h[k] = key, cnt[k] = 0;//在新的位置填入key， 注意将cnt[k]赋值0
    //将cnt[0]赋值为0的意义仅在多重hash时体现---例题acwing4611
    return k;
}
```



**[Snowflake Snow Snowflakes - POJ 3349 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/POJ-3349)**

```c++
#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
#include<vector>
#include<cstdio>
#include<algorithm>
using namespace std;

const int mod = 99991;

struct node
{
	int a[6];//用来存储每片雪花的6个边
	bool operator==(const node& temp)const
	{
		for (int i = 0; i < 6; i++)
			if ((a[0] == temp.a[i]
				&& a[1] == temp.a[(i + 1) % 6]
				&& a[2] == temp.a[(i + 2) % 6]
				&& a[3] == temp.a[(i + 3) % 6]
				&& a[4] == temp.a[(i + 4) % 6]
				&& a[5] == temp.a[(i + 5) % 6]) ||
				(a[0] == temp.a[i]
				&& a[1] == temp.a[(i + 5) % 6]
				&& a[2] == temp.a[(i + 4) % 6]
				&& a[3] == temp.a[(i + 3) % 6]
				&& a[4] == temp.a[(i + 2) % 6]
				&& a[5] == temp.a[(i + 1) % 6]))
				return true;
		return false;
	}//重载等号运算符
};

vector<node>Hash[mod];
node A[100005];

int main(void)
{
	int T;
	cin >> T;
	for (int i = 0; i < T; i++)
	{
		int sum = 0;
		for (int j = 0; j < 6; j++)
		{
			scanf("%d", &A[i].a[j]);
			sum += A[i].a[j];
		}
		sum %= mod;//计算hashcode

		for (int j=0;j<Hash[sum].size();j++)
		{
			if (Hash[sum][j] == A[i])
			{
				cout << "Twin snowflakes found.\n";
				return 0;
			}
		}
		Hash[sum].push_back(A[i]);
	}
	cout << "No two snowflakes are alike.\n";
	return 0;
}
```

# DP组合排列



## 1. n球同，m盒不同，无空箱

==朴素隔板法==

将 $n$ 个球排成一列，有$n-1$个空隙，将之视为分割不同盒子的标志，答案就是 $n-1$ 个空隙中选取 $m-1$ 个，将$n$个球分割成 $m - 1$ 段

$C_{n-1}^{m-1}$

## 2. n球同，m盒不同，允许空盒

==拓展隔板法==

将 $n$ 个球排成一列，再借来 $m$ 个球过来，这样子就有$n + m -1$个空隙，将之视为分割不同盒子的标志，答案就是 $m + n-1$ 个空隙中选取 $m-1$ 个，将$n$个球分割成 $m - 1$ 段，分割完成后将借来的 $m$ 个球再抽走，此时就相当于允许空盒的答案。

$C_{n + m - 1}^{m - 1}$

## 3. n球不同，m盒不同，允许空箱

==乘法原理==

显然每个球的分配是独立的，对于一个球，有 $m$ 种选择（即放入任意 $m$ 个盒的其中一个），共有 $n$ 种球，答案显然为 $m^n$

$m^n$

## 4. n球不同，m盒同，无空箱

==dp==

$f[i][j]$表示 $i$ 个球，$j$ 个盒子的方案 $f[i][j] = f[i-1][j-1]+j*f[i-1][j]$

$且f[0][1] = 1$

直观理解：

每次新开个盒子的方案数来源于两部分，现将第 $i$ 个球抽出来

$dp[i-1][j-1]$：相当于将第 $i$ 个球放在第 $j$ 个盒子，前边的$j - 1$个盒子不动

 $dp[i-1][j]$: 相当于前 $i - 1$个球放入 $j$ 个盒子，最后一个 $i$ 球可以随机放入 $j$ 个盒子的其中一个

```c++
dp[1][1] = 1;
for (int i = 2; i <= n; i++)
    for (int j = 1; j <= m; j++)
        dp[i][j] = dp[i - 1][j - 1] + j * dp[i - 1][j];
```

## 5. n球不同，m盒不同，无空箱

在 4 的基础上，对 $f[n][m]$ 进行全排列

$m!*f[n][m]$

## 6. n球不同，m盒同，允许空箱

$\sum_{i=1}^{m}f[n][i]$





# 离谱题单



https://codeforces.com/contest/279/problem/E //奇怪dp

[Submission #200064967 - Codeforces](https://codeforces.com/contest/1808/submission/200064967) //正难则反

# 数论

## 前置知识

### 0.1 基本定义与记号

> Abstractness is the price of generality.

读者需要知道一些数论相关的基本概念，如素数（质数）的定义，同余符号 $\equiv$ 及其含义，最大公约数 $\gcd$，并掌握基本数论算法如快速幂，辗转相除法求 $\gcd$。

- 整除：若非零整数 $a$ 是整数 $b$ 的因数即 $b \mod a = 0$，则称 $a$ 整除 $b$ 或 $b$ 被 $a$ 整除，记作 $a\mid b$。反之则称 $a$ 不能整除 $b$ 或 $b$ 不能被 $a$ 整除，记作 $a\nmid b$。例如 $2 \mid 4$，$822 \nmid 1064$。
- 同余：$a$ 和 $b$ **同余** 表示整数  $a$ 和 $b$ 模正整数 $p$ 的余数相等，记作 $a\equiv b\pmod p$，读作 $a$ 同余于 $b$。例如 $15 \equiv 57 \pmod {7}$。
- 最大公约数：整数 $a$ 和 $b$ 的 **最大公约数** 是最大的整数  $d$ ，使得 $d$ 整除 $a$ 且 $d$ 整除 $b$，记作 $\gcd(a, b)$。$\gcd(a, b)$ 在不引起歧义的前提下有时会简写为 $(a, b)$。例如 $\gcd(4, 6) = 2$。
- 互质：若整数 $a, b$ 满足 $\gcd(a, b) = 1$，则称 $a, b$ **互质**，记作 $a\perp b$。一般 $a, b$ 均为非负整数。注意，$\gcd(0, i) = i(i \geq 0)$，$1$ 和任何整数互质。例如 $3\perp 8$，$4 \not \perp 6$。
- $\mathbb P$ 表示 **素数集**。$\mathbb P = \{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, \cdots\}$。
- 剩余类：模 $n$ 同余的所有数构成的等价类被称为模 $n$ 的 **剩余类**。当我们在模 $n$ 意义下讨论它们时它们等价。模 $n$ 余 $i$ 的剩余类记作 $K_i$。显然模 $n$ 的剩余类共 $n$ 个。
- 完全剩余系：从 $n$ 个模 $n$ 剩余类中各选一个数 $a_0, a_1, \cdots, a_{n - 1}$，它们构成模 $n$ 的 **完全剩余系**。
- 简化剩余系：从与 $n$ 互质的剩余类中各选一个数 $a_1, a_2, \cdots, a_k$，它们构成模 $n$ 的 **简化剩余系**。读者将在接下来的章节中了解到 $k$ 等于 $\varphi(n)$。简化剩余系又称为 **既约剩余系** 或 **缩系**。
- 乘法逆元：若 $ax \equiv 1 \pmod p$，则称 $x$ 为 $a$ 在模 $p$ 意义下的 **乘法逆元**，记作 $a ^ {-1}$。
- 质因子次数符号：$n$ 当中质因子 $p$ 的次数记作 $v_p(n)$。即 $p ^ {v_p(n)} \mid n$ 且 $p ^ {v_p(n) + 1} \nmid n$。严格意义上应记为 $\nu_p(n)$（希腊字母 nu）。为方便，本文暂记为 $v_p(n)$。
- 各位数字之和符号：$n$ 在 $p$ 进制下的各位数字之和记作 $s_p(n)$。

### 0.2 费马小定理

引理：当 $p$ 是质数时，其因子只有 $1$ 和 $p$ 两个。因此，若两个数相乘是 $p$ 的倍数，其中必然至少有一个是 $p$ 的倍数。

当 $a$ 不是 $p$ 的倍数时，不存在 $x \neq y$ 且 $1 \leq x, y < p$ 使得 $xa \equiv ya\pmod p$。因为据引理，$x - y$ 是 $p$ 的倍数，与 $1\leq x, y< p$ 的限制矛盾。

进一步地，考虑 $1\sim p - 1$ 所有数，它们乘以 $a$ 之后在模 $p$ 意义下互不相同，说明仍得 $1\sim p - 1$ 所有数。

因此，$\prod\limits_{i = 1} ^ {p - 1} i \equiv \prod\limits_{i = 1} ^ {p - 1} ai \pmod p$。又因为 $\prod\limits_{i = 1} ^ {p - 1} i$ 显然不是 $p$ 的倍数，所以

$a ^ {p - 1} \equiv 1 \pmod p $



上述结论称为 **费马小定理**。根据推导过程，它适用于 $p$ 是质数且 $a$ 不是 $p$ 的倍数的情形。

### 0.3 模意义下乘法逆元

根据费马小定理，当 $p$ 为质数时，

$a ^ {-1} \equiv a ^ {p - 2} \pmod p$



据此可快速幂求出一个数在模质数意义下的乘法逆元。

当 $p$ 非质数时，$a$ 有乘法逆元的充要条件为 $a \perp p$。我们将在第一章展开讨论。

给出一些模质数 $p$ 意义下求乘法逆元的常见技巧。

- 线性求逆元：考虑 **增量法**。假设 $1\sim i-1$ 的逆元已知。设 $p = ki + r(0\leq r < i)$，即 $k$ 和 $r$ 分别是 $p$ 对 $i$ 做带余除法的商和余数。$ki + r \equiv 0 \pmod p$，两边同时除以 $ir$，得 $i ^ {-1} \equiv -kr ^ {-1}\equiv -\left\lfloor \dfrac p i \right\rfloor (p\bmod i) ^ {-1}$。时间复杂度线性。
- 线性求任意 $n$ 个数 $a_i(1 \leq a_i < p)$ 的逆元：设 $s$ 为 $a$ 的前缀积。算出 $s_n ^ {-1}$ 后通过 $s_i ^ {-1} = s_{i + 1} ^ {-1} \times a_{i + 1}$ 得到前缀积的逆元，则 $a_i^{-1}=s_{i-1}\times s_i^{-1}$。时间复杂度 $\mathcal{O}(n+\log p)$。

### 0.4 威尔逊定理

#### 0.4.1 一般形式

由于乘法逆元成对出现，这启发我们思考，$1\sim p - 1$ 所有数能否两两配对互为逆元？若可以，说明当 $p$ 是质数时，$(p - 1)! \equiv 1\pmod p$。

可以，但不完全可以，因为 $1$ 和 $-1$ 的逆元均为它本身。但仅有这两个数满足 $x ^ 2\equiv 1\pmod p$。这符合我们的直观认知，毕竟实数域下 $x ^ 2 = 1$ 有且仅有解 $\pm 1$。

证明：求解方程 $x ^ 2\equiv 1\pmod p$。移项，使用平方差公式，$(x - 1)(x + 1) \equiv 0\pmod p$。显然，为使等式左端等于 $0$，必然有 $x \equiv \pm 1\pmod p$。得证。

因此，我们需要对结论进行一些修正，即当 $p$ 是质数时，$(p - 1) ! \equiv 1 \times (p - 1) \equiv -1\pmod p$。特殊考虑 $p = 2$，发现符合该结论。

既然有了充分条件，我们自然会考虑 $p$ 不是质数的情况。

- 当 $p$ 为完全平方数 $q ^ 2$ 时，考虑 $q$ 和 $2q$。它们相乘后模 $p$ 等于 $0$。因此，若 $2q < p$，即 $p$ 为大于 $4$ 的完全平方数时，$(p - 1)!\equiv 0$。
- 当 $p = 4$ 时，$3 ! \equiv 2\pmod 4$。
- 当 $p$ 为大于 $4$ 的非完全平方数时，令 $q$ 为 $p$ 的最小质因子，则 $q \neq \dfrac p q$，故 $(p - 1)!\equiv 0\pmod p$。

综上，我们得到了 **威尔逊定理**：$(p - 1)!\equiv -1\pmod p$ 当且仅当 $p$ 是质数。

#### 0.4.2 扩展形式

我们尝试将威尔逊定理扩展至素数的幂的情形。

考虑 $p ^ k$ 以内所有与 $p$ 互质的数的乘积模 $p ^ k$，记为 $(p ^ k!)_p$。

仍然考虑求解 $x ^ 2 \equiv 1\pmod {p ^ k}$，求出所有逆元为本身的数，并将非 $x$ 的其它所有数与其逆元两两配对（因为我们只考虑与 $p$ 互质的数，所以其在模 $p ^ k$ 意义下存在逆元）。这说明我们只需考虑所有 $x$ 的乘积。

因式分解得到 $(x + 1)(x - 1)\equiv 0\pmod {p ^ k}$。

当 $p > 2$ 时，$x + 1$ 和 $x - 1$ 不可能均是 $p$ 的倍数，必然有 $x + 1\equiv 0\pmod {p ^ k}$ 或 $x - 1\equiv 0\pmod {p ^ k}$。这和一般情况等价，故仍有 $(p ^ k!)_p\equiv -1\pmod {p ^ k}$。

当 $p = 2$ 时，首先有平凡解 $\pm 1$。此外，$x + 1$ 和 $x - 1$ 可能同时为 $2$ 的倍数。但注意到它们不可能同时为 $4$ 的倍数。因此，若 $x + 1$ 和 $x - 1$ 同时为 $2$ 的倍数，除掉不能被 $4$ 整除的那个数（同时模数除以 $2$），得到 $x + 1\equiv 0\pmod {2 ^ {k - 1}}$ 或 $x - 1\equiv 0\pmod {2 ^ {k - 1}}$。这说明当 $p = 2$ 时方程有四个解 $\pm 1$ 和 $2 ^ {k - 1}\pm 1$。注意，当 $k = 1$ 时四个根均重合，此时 $1!\equiv 1\equiv -1\pmod 2$；当 $k = 2$ 时两对根重合，此时 $1\times 3\equiv -1\pmod 4$。否则 $1\times (-1) \times (2 ^ {k - 1} + 1) \times (2 ^ {k - 1} - 1)\equiv 1\pmod {2 ^ k}$。

综上，我们得到如下推论：



$(p ^ k!)_p \equiv \begin{cases} 1 & p = 2 \land k \geq 3 \\ -1 & {\rm otherwise}\end{cases} $



这是威尔逊定理的扩展形式，在 exLucas 中用到了该结论。

# 奇妙板子

```c++
#include <bits/stdc++.h>

using i64 = long long;
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template<i64 P>
struct MLong {
    i64 x;
    constexpr MLong() : x{} {}
    constexpr MLong(i64 x) : x{norm(x % getMod())} {}
    
    static i64 Mod;
    constexpr static i64 getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(i64 Mod_) {
        Mod = Mod_;
    }
    constexpr i64 norm(i64 x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr i64 val() const {
        return x;
    }
    explicit constexpr operator i64() const {
        return x;
    }
    constexpr MLong operator-() const {
        MLong res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MLong inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MLong &operator*=(MLong rhs) & {
        x = mul(x, rhs.x, getMod());
        return *this;
    }
    constexpr MLong &operator+=(MLong rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MLong &operator-=(MLong rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MLong &operator/=(MLong rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MLong operator*(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MLong operator+(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MLong operator-(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MLong operator/(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {
        i64 v;
        is >> v;
        a = MLong(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MLong lhs, MLong rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MLong lhs, MLong rhs) {
        return lhs.val() != rhs.val();
    }
};

template<>
i64 MLong<0LL>::Mod = 1;

template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
    
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};

template<>
int MInt<0>::Mod = 1;

template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();

constexpr int P = 998244353;
using Z = MInt<P>;

struct Comb {
    int n;
    std::vector<Z> _fac;
    std::vector<Z> _invfac;
    std::vector<Z> _inv;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    int H, W, K;
    std::cin >> H >> W >> K;
    
    Z ans = 0;
    for (int i = 1; i <= H; i++) {
        for (int j = 1; j <= W; j++) {
            Z res = 0;
            for (int s = 0; s < 16; s++) {
                int u = __builtin_popcount(s & 3);
                int v = __builtin_popcount(s & 12);
                res += ((u + v) & 1 ? -1 : 1) * comb.binom(std::max(0, i - u) * std::max(0, j - v), K);
            }
            ans += res * (H - i + 1) * (W - j + 1) * i * j;
        }
    }
    ans /= comb.binom(H * W, K);
    std::cout << ans << "\n";
    
    return 0;
}

```
